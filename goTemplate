Jasne! PoniÅ¼ej masz prosty, podzielony na funkcje kod w Pythonie, ktÃ³ry:
- Å‚Ä…czy siÄ™ z Elasticsearch,
- listuje index templates (composable i opcjonalnie legacy),
- aktualizuje (merge) lub caÅ‚kowicie podmienia istniejÄ…cy template przez REST API.

Wymaga: pip install requests

```python
import base64
import copy
import json
from typing import Any, Dict, List, Optional, Tuple

import requests
from requests.auth import HTTPBasicAuth


# ----------------------------- PoÅ‚Ä…czenie / Session -----------------------------

def create_es_session(
    base_url: str,
    basic_auth: Optional[Tuple[str, str]] = None,
    api_key: Optional[str | Tuple[str, str]] = None,
    verify: bool | str = True,  # True/False lub Å›cieÅ¼ka do CA bundle
    default_headers: Optional[Dict[str, str]] = None,
) -> requests.Session:
    """
    Tworzy sesjÄ™ HTTP do Elasticsearch z nagÅ‚Ã³wkami i uwierzytelnieniem.
    - base_url: np. "https://localhost:9200"
    - basic_auth: ("user", "pass")
    - api_key: base64 ApiKey lub tuple ("id", "api_key") â€“ zostanie zbase64-owane
    - verify: True/False lub Å›cieÅ¼ka do certyfikatu CA
    """
    s = requests.Session()
    s.verify = verify
    headers = {"Content-Type": "application/json"}
    if default_headers:
        headers.update(default_headers)

    if api_key:
        if isinstance(api_key, tuple):
            raw = f"{api_key[0]}:{api_key[1]}".encode("utf-8")
            encoded = base64.b64encode(raw).decode("ascii")
            headers["Authorization"] = f"ApiKey {encoded}"
        else:
            # ZakÅ‚adamy, Å¼e to juÅ¼ jest gotowy base64 ApiKey
            headers["Authorization"] = f"ApiKey {api_key}"

    if basic_auth:
        s.auth = HTTPBasicAuth(basic_auth[0], basic_auth[1])

    s.headers.update(headers)
    # Timeout ustawiamy per-request (w helperze es_request)
    s.base_url = base_url.rstrip("/")
    return s


def es_request(
    session: requests.Session,
    method: str,
    path: str,
    params: Optional[Dict[str, Any]] = None,
    body: Optional[Dict[str, Any]] = None,
    timeout: float = 30.0,
) -> Any:
    """
    Helper do wykonywania requestÃ³w na endpointy ES.
    Zwraca zdekodowane JSON (jeÅ›li jest), albo None dla pustej odpowiedzi.
    """
    url = f"{session.base_url}/{path.lstrip('/')}"
    resp = session.request(method, url, params=params, json=body, timeout=timeout)
    if not resp.ok:
        raise RuntimeError(
            f"Elasticsearch API error {resp.status_code} {resp.reason}: {resp.text}"
        )
    if resp.text.strip():
        try:
            return resp.json()
        except json.JSONDecodeError:
            return resp.text
    return None


# ----------------------------- Listing templatek -------------------------------

def list_index_templates(
    session: requests.Session,
    include_legacy: bool = False,
    timeout: float = 30.0,
) -> Dict[str, List[str]]:
    """
    Zwraca nazwy templatek:
      - composable (/_index_template)
      - legacy (/_template) jeÅ›li include_legacy=True
    """
    out: Dict[str, List[str]] = {"composable": []}
    try:
        data = es_request(session, "GET", "/_index_template", timeout=timeout)
        out["composable"] = [t["name"] for t in data.get("index_templates", [])]
    except Exception:
        out["composable"] = []

    if include_legacy:
        try:
            data = es_request(session, "GET", "/_template", timeout=timeout)
            out["legacy"] = list(data.keys()) if isinstance(data, dict) else []
        except Exception:
            out["legacy"] = []

    return out


def get_index_template(
    session: requests.Session,
    name: str,
    composable: bool = True,
    timeout: float = 30.0,
) -> Dict[str, Any]:
    """
    Pobiera (peÅ‚ne) ciaÅ‚o templatki po nazwie.
    - composable=True -> GET /_index_template/{name}
    - composable=False (legacy) -> GET /_template/{name}
    """
    if composable:
        data = es_request(session, "GET", f"/_index_template/{name}", timeout=timeout)
        items = data.get("index_templates", [])
        if not items:
            raise KeyError(f"Composable index template '{name}' nie znaleziono")
        return items[0]["index_template"]
    else:
        data = es_request(session, "GET", f"/_template/{name}", timeout=timeout)
        if name not in data:
            raise KeyError(f"Legacy index template '{name}' nie znaleziono")
        return data[name]


# ----------------------------- Replace / Update --------------------------------

def put_index_template(
    session: requests.Session,
    name: str,
    body: Dict[str, Any],
    composable: bool = True,
    create: bool = False,
    cause: Optional[str] = None,
    timeout: float = 30.0,
) -> Any:
    """
    Tworzy lub podmienia indeksowÄ… templatkÄ™.
    - create=True spowoduje bÅ‚Ä…d, jeÅ›li juÅ¼ istnieje
    - cause=opis pojawi siÄ™ w historii audytu (cluster metadata)
    """
    params: Dict[str, Any] = {}
    if create:
        params["create"] = "true"
    if cause:
        params["cause"] = cause

    path = f"/_index_template/{name}" if composable else f"/_template/{name}"
    return es_request(session, "PUT", path, params=params, body=body, timeout=timeout)


def deep_merge(a: Dict[str, Any], b: Dict[str, Any]) -> Dict[str, Any]:
    """
    GÅ‚Ä™boki merge sÅ‚ownikÃ³w. WartoÅ›ci z b nadpisujÄ… a.
    """
    res = copy.deepcopy(a)
    for k, v in b.items():
        if k in res and isinstance(res[k], dict) and isinstance(v, dict):
            res[k] = deep_merge(res[k], v)
        else:
            res[k] = v
    return res


def update_index_template(
    session: requests.Session,
    name: str,
    patch: Dict[str, Any],
    composable: bool = True,
    timeout: float = 30.0,
) -> Dict[str, Any]:
    """
    Aktualizacja istniejÄ…cej templatki przez merge (patch).
    1) Pobiera bieÅ¼Ä…ce ciaÅ‚o,
    2) Merguje z 'patch',
    3) PUT caÅ‚oÅ›ci (zaktualizowanej).
    """
    current = get_index_template(session, name, composable=composable, timeout=timeout)
    merged = deep_merge(current, patch)
    put_index_template(session, name, merged, composable=composable, timeout=timeout)
    return merged


# ----------------------------- PrzykÅ‚ad uÅ¼ycia ---------------------------------

if __name__ == "__main__":
    # UzupeÅ‚nij pod siebie:
    BASE_URL = "https://localhost:9200"
    BASIC_AUTH = ("elastic", "changeme")     # albo None
    API_KEY = None                           # np. "BASE64_API_KEY" lub ("id","key")
    VERIFY = False                           # w dev moÅ¼na False; w prod -> True/Å›cieÅ¼ka do CA

    s = create_es_session(BASE_URL, basic_auth=BASIC_AUTH, api_key=API_KEY, verify=VERIFY)

    # 1) Lista templatek
    templates = list_index_templates(s, include_legacy=True)
    print("Templates:", templates)

    # 2) Podmiana (replace) composable index template
    # Uwaga: dla composable template body ma strukturÄ™:
    # { "index_patterns": [...], "template": { "settings": {...}, "mappings": {...}, "aliases": {...} }, ... }
    new_template_body = {
        "index_patterns": ["my-logs-*"],
        "priority": 500,
        "template": {
            "settings": {
                "number_of_shards": 1,
                "number_of_replicas": 0
            },
            "mappings": {
                "properties": {
                    "@timestamp": {"type": "date"},
                    "message": {"type": "text"}
                }
            }
        },
        "version": 1,
        "metadata": {"owner": "team-observability"}
    }
    put_index_template(s, "my_logs_template", new_template_body, composable=True, create=False, cause="initial replace")
    print("Zrobione: replace composable template 'my_logs_template'")

    # 3) Update (merge/patch) â€“ np. dorzucamy ILM i alias
    patch_body = {
        "template": {
            "settings": {
                "index.lifecycle.name": "my-ilm-policy"
            },
            "aliases": {
                "my-logs-write": {"is_write_index": True}
            }
        }
    }
    updated = update_index_template(s, "my_logs_template", patch_body, composable=True)
    print("Zaktualizowane (merged):", json.dumps(updated, indent=2, ensure_ascii=False))

    # 4) Opcjonalnie: legacy template (dla starszych klastrÃ³w)
    legacy_body = {
        "index_patterns": ["legacy-*"],
        "order": 0,
        "settings": {"number_of_shards": 1},
        "mappings": {"_source": {"enabled": True}},
        "aliases": {"legacy-alias": {}},
        "version": 1
    }
    put_index_template(s, "legacy_template_demo", legacy_body, composable=False, create=False)
    print("Zrobione: replace legacy template 'legacy_template_demo'")
```

JeÅ›li chcesz wersjÄ™ na oficjalnym kliencie Pythona (elasticsearch>=8), teÅ¼ podrzucÄ™ â€” daj znaÄ‡, ktÃ³rÄ… wersjÄ™ ES masz (7.x vs 8.x), bo rÃ³Å¼niÄ… siÄ™ endpointy i metody w kliencie.

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$44
Oto kompletny kod w Pythonie, podzielony na funkcje, ktÃ³ry realizuje Twoje wymagania.

Skrypt wykorzystuje oficjalnÄ… bibliotekÄ™ klienta **`elasticsearch`**. JeÅ›li jej nie masz, zainstaluj jÄ… komendÄ…:

```bash
pip install elasticsearch
```

### Kod Python

Skrypt obsÅ‚uguje nowoczesne **Composable Index Templates** (standard w Elasticsearch 7.8+ i 8.x).

```python
import os
import json
from elasticsearch import Elasticsearch, exceptions
import warnings

# WyÅ‚Ä…czenie ostrzeÅ¼eÅ„ o braku SSL (opcjonalne, przydatne przy lokalnych testach)
from urllib3.exceptions import InsecureRequestWarning
warnings.simplefilter('ignore', InsecureRequestWarning)

def connect_to_elasticsearch(host: str, username: str = None, password: str = None, verify_certs: bool = True) -> Elasticsearch:
    """
    NawiÄ…zuje poÅ‚Ä…czenie z klastrem Elasticsearch.
    """
    try:
        # Konfiguracja poÅ‚Ä…czenia
        # Dla ES 8.x uÅ¼ywamy basic_auth, dla starszych wersji moÅ¼e byÄ‡ potrzebne http_auth
        client = Elasticsearch(
            hosts=[host],
            basic_auth=(username, password) if username and password else None,
            verify_certs=verify_certs,
            ssl_show_warn=verify_certs
        )
        
        # Sprawdzenie poÅ‚Ä…czenia
        info = client.info()
        print(f"âœ… PoÅ‚Ä…czono z klastrem: {info['cluster_name']} (Wersja: {info['version']['number']})")
        return client
        
    except Exception as e:
        print(f"âŒ BÅ‚Ä…d poÅ‚Ä…czenia z Elasticsearch: {e}")
        return None

def list_index_templates(es_client: Elasticsearch, name_pattern: str = "*"):
    """
    Listuje dostÄ™pne szablony indeksÃ³w (Composable Index Templates).
    """
    try:
        # Pobieranie szablonÃ³w
        response = es_client.indices.get_index_template(name=name_pattern)
        templates = response.get('index_templates', [])

        if not templates:
            print(f"â„¹ï¸ Nie znaleziono szablonÃ³w pasujÄ…cych do wzorca: '{name_pattern}'")
            return

        print(f"\nğŸ“‹ Lista szablonÃ³w ({len(templates)}):")
        for tmpl in templates:
            name = tmpl['name']
            patterns = tmpl['index_template']['index_patterns']
            print(f" - Nazwa: {name} | Wzorce indeksÃ³w: {patterns}")
            
        return templates

    except exceptions.NotFoundError:
        print(f"â„¹ï¸ Nie znaleziono szablonÃ³w.")
    except Exception as e:
        print(f"âŒ BÅ‚Ä…d podczas listowania szablonÃ³w: {e}")

def create_or_update_template(es_client: Elasticsearch, template_name: str, template_body: dict):
    """
    Tworzy nowy szablon lub nadpisuje istniejÄ…cy (PUT request).
    W Elasticsearch operacja PUT dziaÅ‚a jako "Create or Replace".
    """
    try:
        print(f"\nğŸ”„ PrÃ³ba aktualizacji/utworzenia szablonu: '{template_name}'...")
        
        response = es_client.indices.put_index_template(
            name=template_name,
            body=template_body
        )
        
        if response.get('acknowledged'):
            print(f"âœ… Sukces: Szablon '{template_name}' zostaÅ‚ zaktualizowany/utworzony.")
        else:
            print(f"âš ï¸ OstrzeÅ¼enie: Operacja zakoÅ„czona, ale brak potwierdzenia 'acknowledged'.")
            
    except exceptions.RequestError as e:
        print(f"âŒ BÅ‚Ä…d zapytania (zÅ‚a skÅ‚adnia JSON?): {e}")
    except Exception as e:
        print(f"âŒ BÅ‚Ä…d podczas aktualizacji szablonu: {e}")

# --- PRZYKÅAD UÅ»YCIA ---

if __name__ == "__main__":
    # 1. Konfiguracja
    ES_HOST = "https://localhost:9200"  # Adres klastra
    ES_USER = "elastic"                 # UÅ¼ytkownik
    ES_PASS = "twoje_haslo"             # HasÅ‚o (zmienna Å›rodowiskowa jest bezpieczniejsza)
    
    # 2. PoÅ‚Ä…czenie
    # verify_certs=False uÅ¼ywamy tylko przy self-signed certyfikatach (np. lokalny docker)
    es = connect_to_elasticsearch(ES_HOST, ES_USER, ES_PASS, verify_certs=False)

    if es:
        # 3. Wylistowanie obecnych szablonÃ³w
        list_index_templates(es)

        # 4. Definicja nowego szablonu (lub aktualizacja istniejÄ…cego)
        # PrzykÅ‚ad prostego szablonu
        my_template_name = "logs-app-template"
        my_template_body = {
            "index_patterns": ["logs-app-*"],
            "priority": 100,
            "template": {
                "settings": {
                    "number_of_shards": 1,
                    "number_of_replicas": 1
                },
                "mappings": {
                    "properties": {
                        "timestamp": {"type": "date"},
                        "level": {"type": "keyword"},
                        "message": {"type": "text"}
                    }
                }
            },
            "_meta": {
                "description": "Szablon dla logÃ³w aplikacji utworzony przez Python"
            }
        }

        # 5. Wykonanie aktualizacji/utworzenia
        create_or_update_template(es, my_template_name, my_template_body)

        # 6. Ponowne wylistowanie, aby potwierdziÄ‡ zmiany
        print("\n--- Po aktualizacji ---")
        list_index_templates(es, name_pattern="logs-app-*")
```

### WyjaÅ›nienie kluczowych elementÃ³w:

1.  **Biblioteka `elasticsearch`**: Kod jest napisany pod wersjÄ™ biblioteki 8.x, ktÃ³ra jest najbardziej aktualna. Metoda `Elasticsearch(...)` przyjmuje parametry `basic_auth` dla loginu i hasÅ‚a.
2.  **`put_index_template`**: Ta metoda API Elasticsearch jest **idempotentna**. Oznacza to, Å¼e jeÅ›li szablon o danej nazwie nie istnieje, zostanie utworzony. JeÅ›li istnieje â€“ zostanie w caÅ‚oÅ›ci nadpisany nowÄ… definicjÄ…. Nie ma potrzeby oddzielnych funkcji dla "update" i "create".
3.  **Composable vs Legacy**: Kod uÅ¼ywa endpointÃ³w `_index_template` (nowoczesne szablony, ktÃ³re moÅ¼na skÅ‚adaÄ‡ z komponentÃ³w). JeÅ›li uÅ¼ywasz bardzo starego Elasticsearcha (wersja 6 lub starsza 7), musiaÅ‚byÅ› uÅ¼yÄ‡ funkcji `indices.put_template` (tzw. legacy templates).
4.  **BezpieczeÅ„stwo SSL**: W przykÅ‚adzie ustawiÅ‚em `verify_certs=False`, co jest typowe przy pracy z lokalnym Dockerem i certyfikatami self-signed. Na produkcji naleÅ¼y zmieniÄ‡ to na `True` lub podaÄ‡ Å›cieÅ¼kÄ™ do pliku CA.
55555555555555555555555555555555555555555555555555555555555

apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources: []  # nie dodajemy zasobÃ³w; uÅ¼ywamy tylko patchy na tym, co wyrenderuje Helm
patchesStrategicMerge:
  - remove-fleet-token-env.yaml


apiVersion: apps/v1
kind: Deployment
metadata:
  name: elastic-agent             # dostosuj do swojej nazwy
spec:
  template:
    spec:
      containers:
        - name: elastic-agent     # dostosuj do nazwy kontenera w chartcie
          env:
            - name: FLEET_ENROLLMENT_TOKEN
              value: "dummy"
              $patch: delete


apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: elastic-agent-clusterA
spec:
  project: default
  sources:
    - repoURL: https://git.example.com/helm-charts.git
      targetRevision: main
      chart: elastic-agent
      helm:
        valueFiles:
          - $values/clusterA/values/c1c.yaml
        postRenderer:
          kustomize:
            path: clusterA/overlays/remove-dummy-env
    - repoURL: https://git.example.com/agent-config.git
      targetRevision: main
      ref: values
      path: clusterA/manifests      # opcjonalnie: tu moÅ¼esz mieÄ‡ VSS i inne CRD
  destination:
    server: https://kubernetes.default.svc
    namespace: monitoring
  syncPolicy:
    automated:
      prune: true
      selfHeal: true



------------------------------------------
Åšwietne pytanie ğŸ™‚ â€“ jeÅ›li nie chcesz ruszaÄ‡ **oryginalnego Helm charta**, masz kilka sposobÃ³w, Å¼eby obejÅ›Ä‡ logikÄ™ ustawiania `runAsUser: 0` i capabilities:

---

## ğŸ”§ RozwiÄ…zania bez modyfikacji charta

### 1. **Override przez `values.yaml`**
WiÄ™kszoÅ›Ä‡ chartÃ³w pozwala nadpisaÄ‡ `securityContext` w `values.yaml`.  
SprawdÅº, czy w Twoim chartcie istnieje coÅ› takiego jak:

```yaml
agent:
  presets:
    default:
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000
        capabilities: {}
```

JeÅ›li tak â€“ to nadpisze wartoÅ›ci ustawiane przez helpery.  
WaÅ¼ne: w Helm logika `set` dziaÅ‚a tak, Å¼e **ostatnie przypisanie wygrywa**. JeÅ›li w `values.yaml` jawnie podasz `securityContext`, to helper nie nadpisze tego.

---

### 2. **Patch przez `helm upgrade --set`**
MoÅ¼esz wprost przy instalacji/upgrade podaÄ‡:

```bash
helm upgrade elastic-agent ./elastic-agent-chart \
  --set agent.presets.default.securityContext.runAsUser=1000 \
  --set agent.presets.default.securityContext.runAsGroup=1000 \
  --set agent.presets.default.securityContext.capabilities={}
```

To pozwala uniknÄ…Ä‡ edycji plikÃ³w charta, a jedynie sterujesz wartoÅ›ciami.

---

### 3. **Helm post-renderer (np. `kustomize`)**
Helm ma opcjÄ™ `--post-renderer`, gdzie moÅ¼esz przepuÅ›ciÄ‡ wygenerowane manifesty przez narzÄ™dzie (np. `kustomize` albo wÅ‚asny skrypt), ktÃ³re usunie/zmieni `runAsUser: 0` i capabilities.  
PrzykÅ‚ad prostego patcha w `kustomize`:

```yaml
patchesStrategicMerge:
- |
  apiVersion: apps/v1
  kind: DaemonSet
  metadata:
    name: elastic-agent
  spec:
    template:
      spec:
        containers:
        - name: elastic-agent
          securityContext:
            runAsUser: 1000
            runAsGroup: 1000
            capabilities: {}
```

---

### 4. **Helm hooks / dodatkowy overlay**
MoÅ¼esz teÅ¼ stworzyÄ‡ wÅ‚asny chart typu â€wrapperâ€, ktÃ³ry jako dependency wciÄ…ga oryginalny chart i nadpisuje tylko `values.yaml`. To daje czystÄ… separacjÄ™: oryginalny chart zostaje nietkniÄ™ty, a Ty masz wÅ‚asne ustawienia.

---

âœ… Podsumowanie:  
Nie musisz edytowaÄ‡ helperÃ³w â€“ wystarczy nadpisaÄ‡ `securityContext` w `values.yaml` albo przez `--set`, albo uÅ¼yÄ‡ post-renderera (`kustomize`). To najczystsze rozwiÄ…zanie, bo nie ruszasz ÅºrÃ³dÅ‚a charta, a masz peÅ‚nÄ… kontrolÄ™ nad UID/GID i capabilities.

---

Chcesz, Å¼ebym przygotowaÅ‚ gotowy przykÅ‚ad `values.yaml`, ktÃ³ry caÅ‚kowicie wyÅ‚Ä…cza capabilities i ustawia `runAsUser/runAsGroup` na 1000?




--------------------------------------------------------------------
--query-range.split-interval=24h
--query-range.max-query-length=1d
--query-frontend.downsampling.auto-downsampling=true

-------------------------------------------
**NajproÅ›ciej: Go templates w Helm to â€programowanie w YAML-uâ€. Masz plik `values.yaml` (dane wejÅ›ciowe), szablon z logikÄ… (`if`, `range`, `with`, `define/include`), a Helm generuje wynikowy manifest. PokaÅ¼Ä™ Ci kaÅ¼dy komponent krok po kroku: wartoÅ›ci â†’ szablon â†’ wynik.**

---

# 1. **if / else**

### values.yaml
```yaml
ingress:
  enabled: true
```

### szablon
```yaml
{{- if .Values.ingress.enabled }}
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-app
{{- else }}
# Ingress wyÅ‚Ä…czony
{{- end }}
```

### wynik
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-app
```

---

# 2. **range** (pÄ™tla)

### values.yaml
```yaml
extraEnv:
  - name: ENV
    value: prod
  - name: DEBUG
    value: "false"
```

### szablon
```yaml
env:
{{- range .Values.extraEnv }}
  - name: {{ .name }}
    value: {{ .value | quote }}
{{- end }}
```

### wynik
```yaml
env:
  - name: ENV
    value: "prod"
  - name: DEBUG
    value: "false"
```

---

# 3. **with** (zmiana kontekstu)

### values.yaml
```yaml
resources:
  limits:
    cpu: "500m"
    memory: "512Mi"
```

### szablon
```yaml
{{- with .Values.resources }}
resources:
  limits:
    cpu: {{ .limits.cpu }}
    memory: {{ .limits.memory }}
{{- end }}
```

### wynik
```yaml
resources:
  limits:
    cpu: 500m
    memory: 512Mi
```

---

# 4. **define / include** (funkcje szablonowe)

### helpers.tpl
```yaml
{{- define "myapp.labels" -}}
app: my-app
release: {{ .Release.Name }}
{{- end }}
```

### szablon
```yaml
metadata:
  labels:
{{ include "myapp.labels" . | nindent 4 }}
```

### wynik
```yaml
metadata:
  labels:
    app: my-app
    release: my-release
```

---

# 5. **funkcje i potoki**

### values.yaml
```yaml
service:
  type: ""
  port: 8080
```

### szablon
```yaml
spec:
  type: {{ .Values.service.type | default "ClusterIP" }}
  ports:
    - port: {{ .Values.service.port }}
```

### wynik
```yaml
spec:
  type: ClusterIP
  ports:
    - port: 8080
```

---

# 6. **globalny kontekst `$.`**

### values.yaml
```yaml
hosts:
  - api.example.com
  - app.example.com
```

### szablon
```yaml
{{- range .Values.hosts }}
- host: {{ . }}
  name: {{ $.Release.Name }}-{{ . | replace "." "-" }}
{{- end }}
```

### wynik
```yaml
- host: api.example.com
  name: my-release-api-example-com
- host: app.example.com
  name: my-release-app-example-com
```

---

# âœ… Podsumowanie

- **if/else** â†’ warunki (wstawia fragmenty tylko gdy speÅ‚nione).  
- **range** â†’ pÄ™tle po listach/mapach.  
- **with** â†’ skraca Å›cieÅ¼ki do zagnieÅ¼dÅ¼onych wartoÅ›ci.  
- **define/include** â†’ reuÅ¼ywalne fragmenty (jak funkcje).  
- **funkcje/pipelines** â†’ transformacje (`default`, `quote`, `toYaml`, `nindent`).  
- **$.** â†’ odwoÅ‚anie do globalnego kontekstu, gdy jesteÅ› w pÄ™tli.  

---

ğŸ‘‰ Chcesz, Å¼ebym przygotowaÅ‚ **peÅ‚ny mini-chart** (plik `Chart.yaml`, `values.yaml`, `templates/deployment.yaml`) i pokazaÅ‚ jak wyglÄ…da wynik `helm template`? To da Ci kompletny obraz procesu od A do Z.
