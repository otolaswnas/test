(
  # Krytyczny stan: etcd lub kube-apiserver niedostępne
  max by(operator) (
    (cluster_operator_conditions{condition="Available",status="false",name=~"etcd|kube-apiserver"})
  ) * 2
)
OR on() (
  # Anomalie: są zdegradowane operatory, ale krytyczne działają
  clamp_max(
    sum(cluster_operator_conditions{condition="Degraded",status="true"}) > 0,
    1
  )
)
OR on() (
  # OK: brak degradacji, wszystko dostępne
  0
)




------------------------###############################33
Poniżej gotowa treść do zapisania jako plik TXT (np. ocp_cluster_3stats.txt). Zawiera 3 osobne panele Stat (Grafana 11.4), każdy zwraca 0/1/2:
- 0 = Available
- 1 = Warning
- 2 = Critical
Zadbane są porównania z bool oraz „baza zer”, aby uniknąć “No data”.

------------------------------------------------------------
Tytuł: OCP – 3 staty per klaster (rozmiar klastra, NotReady, Pressure)

Założenia
- Datasource: Prometheus
- Label klastra: openshiftcluster
- Zmienna: $openshiftcluster (multi, Include All, All value: .*)
  - Query: label_values(kube_node_info, openshiftcluster)
- W panelach Stat:
  - Query options: Instant = ON
  - Value options: Fields = All values, Calculation = Last (not null)
  - Value mappings: 0→Available, 1→Warning, 2→Critical
  - Thresholds: 0→Green, 1→Yellow, 2→Red
  - Display name/Legend: {{openshiftcluster}}

Panel 1 — Minimalny rozmiar klastra
Zasada:
- Critical (2): mniej niż 3 master + mniej niż 3 worker (czyli którykolwiek z nich < 3)
- Warning (1): dokładnie 3 mastery i 3 workery
- Available (0): więcej niż minimalny (masters > 3 i workers > 3)

Wariant A (masz kube_node_role – liczymy master/worker osobno):
PromQL:
clamp_max(
  2 * clamp_max(
    (
      (
        (
          count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"})
          -
          on (openshiftcluster)
          (
            count by (openshiftcluster) (
              sum by (node, openshiftcluster) (
                kube_node_role{role=~"master|control-plane", openshiftcluster=~"$openshiftcluster"}
              ) > 0
            )
            or on (openshiftcluster)
            (0 * count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"}))
          )
        ) < bool 3
      )
      + on (openshiftcluster)
      (
        (
          count by (openshiftcluster) (
            sum by (node, openshiftcluster) (
              kube_node_role{role=~"master|control-plane", openshiftcluster=~"$openshiftcluster"}
            ) > 0
          )
          or on (openshiftcluster)
          (0 * count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"}))
        ) < bool 3
      )
    ), 1
  )
  +
  1 * (
    (
      (
        (
          count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"})
          -
          on (openshiftcluster)
          (
            count by (openshiftcluster) (
              sum by (node, openshiftcluster) (
                kube_node_role{role=~"master|control-plane", openshiftcluster=~"$openshiftcluster"}
              ) > 0
            )
            or on (openshiftcluster)
            (0 * count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"}))
          )
        ) == bool 3
      )
      * on (openshiftcluster)
      (
        (
          count by (openshiftcluster) (
            sum by (node, openshiftcluster) (
              kube_node_role{role=~"master|control-plane", openshiftcluster=~"$openshiftcluster"}
            ) > 0
          )
          or on (openshiftcluster)
          (0 * count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"}))
        ) == bool 3
      )
    )
  )
, 2)

Wariant B (fallback – bez kube_node_role; liczymy tylko łączną liczbę nodów):
Zasada: minimalny rozmiar = 6 nodów
- Critical: total_nodes < 6
- Warning: total_nodes == 6
- Available: total_nodes > 6

PromQL:
clamp_max(
  2 * (
    count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"}) < bool 6
  )
  +
  1 * (
    count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"}) == bool 6
  )
, 2)

Panel 2 — Nody NotReady (Ready=false)
Zasada:
- Critical (2): NotReady > 3
- Warning (1): NotReady == 2
- Available (0): w pozostałych przypadkach (0 lub 1, albo 3 dokładnie jeśli chcesz inaczej – patrz uwagi)

PromQL:
clamp_max(
  2 * (
    (
      (
        sum by (openshiftcluster) (
          kube_node_status_condition{condition="Ready", status="false", openshiftcluster=~"$openshiftcluster"} == 1
        )
        or on (openshiftcluster)
        (0 * count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"}))
      ) > bool 3
    )
  )
  +
  1 * (
    (
      (
        sum by (openshiftcluster) (
          kube_node_status_condition{condition="Ready", status="false", openshiftcluster=~"$openshiftcluster"} == 1
        )
        or on (openshiftcluster)
        (0 * count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"}))
      ) == bool 2
    )
  )
, 2)

Uwagi:
- Jeśli chcesz traktować „≥ 3 NotReady” jako czerwone, zmień > bool 3 na >= bool 3.
- Jeśli chcesz wliczać Unknown jako „niegotowe”, zamiast status="false" użyj status!="true".

Panel 3 — Presja (Memory/Disk/PID)
Zasada:
- Critical (2): którykolwiek typ presji (Memory/Disk/PID) ma > 3 nodów z aktywną presją
- Warning (1): którykolwiek typ presji ma > 1 node z aktywną presją
- Available (0): max z tych trzech zliczeń ≤ 1

PromQL:
clamp_max(
  2 * clamp_max(
    (
      (
        (
          sum by (openshiftcluster) (
            kube_node_status_condition{condition="MemoryPressure", status="true", openshiftcluster=~"$openshiftcluster"} == 1
          )
          or on (openshiftcluster)
          (0 * count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"}))
        ) > bool 3
      )
      + on (openshiftcluster)
      (
        (
          sum by (openshiftcluster) (
            kube_node_status_condition{condition="DiskPressure", status="true", openshiftcluster=~"$openshiftcluster"} == 1
          )
          or on (openshiftcluster)
          (0 * count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"}))
        ) > bool 3
      )
      + on (openshiftcluster)
      (
        (
          sum by (openshiftcluster) (
            kube_node_status_condition{condition="PIDPressure", status="true", openshiftcluster=~"$openshiftcluster"} == 1
          )
          or on (openshiftcluster)
          (0 * count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"}))
        ) > bool 3
      )
    ), 1
  )
  +
  1 * clamp_max(
    (
      (
        (
          sum by (openshiftcluster) (
            kube_node_status_condition{condition="MemoryPressure", status="true", openshiftcluster=~"$openshiftcluster"} == 1
          )
          or on (openshiftcluster)
          (0 * count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"}))
        ) > bool 1
      )
      + on (openshiftcluster)
      (
        (
          sum by (openshiftcluster) (
            kube_node_status_condition{condition="DiskPressure", status="true", openshiftcluster=~"$openshiftcluster"} == 1
          )
          or on (openshiftcluster)
          (0 * count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"}))
        ) > bool 1
      )
      + on (openshiftcluster)
      (
        (
          sum by (openshiftcluster) (
            kube_node_status_condition{condition="PIDPressure", status="true", openshiftcluster=~"$openshiftcluster"} == 1
          )
          or on (openshiftcluster)
          (0 * count by (openshiftcluster) (kube_node_info{openshiftcluster=~"$openshiftcluster"}))
        ) > bool 1
      )
    ), 1
  )
, 2)

Notatki końcowe
- Porównania z „bool” zwracają 0/1 zamiast filtrować serie — dzięki temu Stat nie pokaże „No data”.
- „Baza zer” (or on (openshiftcluster) 0*count(...kube_node_info...)) zapewnia, że każdy klaster dostanie 0, nawet jeśli dany licznik (np. NotReady) nie występuje.
- Jeśli nie masz kube_node_role, w Panelu 1 użyj Wariantu B (na total_nodes).
- Jeśli chcesz liczyć nody „produkcyjne” (bez cordon/drain), możesz dodać filtr and on (node) kube_node_spec_unschedulable == 0 w licznikach.

Koniec pliku.
------------------------------------------------------------
