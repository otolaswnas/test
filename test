Poniżej masz komplet “od A do Z” do uruchomienia APM Server 8.14.3 w trybie offline (bez internetu), jako własny Helm chart. Wystarczy utworzyć pliki w podanych lokalizacjach, podmienić kilka wartości i zainstalować.

Plan
- przygotuj prosty chart Helm: offline/apm-server/… (pliki poniżej)
- przygotuj obraz apm-server:8.14.3 w wewnętrznym registry
- utwórz Secret z certami do Kafki (PEM albo PKCS#12/JKS)
- zainstaluj: helm upgrade --install …

1) Struktura katalogów
Utwórz katalogi i pliki (nazwa “offline” dowolna):
- offline/apm-server/Chart.yaml
- offline/apm-server/values.yaml
- offline/apm-server/templates/_helpers.tpl
- offline/apm-server/templates/configmap.yaml
- offline/apm-server/templates/deployment.yaml
- offline/apm-server/templates/service.yaml
- offline/apm-server/templates/serviceaccount.yaml
- offline/apm-server/templates/NOTES.txt

2) Zawartość plików chartu

offline/apm-server/Chart.yaml
```yaml
apiVersion: v2
name: apm-server
description: Minimalny offline chart dla Elastic APM Server (8.14.3)
type: application
version: 8.14.3
appVersion: "8.14.3"
kubeVersion: ">=1.20.0-0"
```

offline/apm-server/values.yaml
- Podmień:
  - .image na Twój wewnętrzny registry (np. registry.local/elastic/apm-server)
  - hosts Kafki
  - Secret z certami (kafka-secret-elk) i nazwy plików w nim
  - jeśli używasz SASL zamiast mTLS – odkomentuj sekcję SASL i wprowadź env (sekcja envFrom)
```yaml
replicaCount: 2

image: "registry.local/elastic/apm-server"  # <- Twój wewnętrzny registry
imageTag: "8.14.3"
imagePullPolicy: IfNotPresent
imagePullSecrets: []  # np. [{name: regcred}]

nameOverride: ""
fullnameOverride: ""

apmConfig:
  apm-server.yml: |
    apm-server:
      host: "0.0.0.0:8200"
    # Jeśli intake wymaga tokenu:
    # apm-server.auth.secret_token: "${APM_SECRET_TOKEN}"

    # OUTPUT: Kafka (PEM / mTLS – domyślnie)
    output.kafka:
      hosts: ["kafka-1:9093","kafka-2:9093"]
      topic: "apm-json"
      ssl.enabled: true
      ssl.certificate_authorities: ["/usr/share/apm-server/config/kafka-tls/ca-bungle.crt"]
      ssl.certificate: "/usr/share/apm-server/config/kafka-tls/tls-bungle.crt"
      ssl.key: "/usr/share/apm-server/config/kafka-tls/tls.key"

      # (ZAMIENNIE: SASL/SCRAM – odkomentuj jeśli używasz)
      # username: "${KAFKA_USERNAME}"
      # password: "${KAFKA_PASSWORD}"
      # sasl.mechanism: "scram-sha-512"

      # (ZAMIENNIE: PKCS#12)
      # ssl.enabled: true
      # ssl.keystore.path: "/usr/share/apm-server/config/kafka-tls/client.p12"
      # ssl.keystore.password: "${KS_PASS}"
      # (opcjonalnie truststore)
      # ssl.truststore.path: "/usr/share/apm-server/config/kafka-tls/truststore.p12"
      # ssl.truststore.password: "${TS_PASS}"

      # (ZAMIENNIE: JKS)
      # ssl.enabled: true
      # ssl.keystore.path: "/usr/share/apm-server/config/kafka-tls/client.jks"
      # ssl.keystore.password: "${KS_PASS}"
      # ssl.truststore.path: "/usr/share/apm-server/config/kafka-tls/truststore.jks"
      # ssl.truststore.password: "${TS_PASS}"

# Montujemy Secret z certami/keystore do ścieżek użytych w apm-server.yml
secretMounts: []
# Przykład (PEM):
# secretMounts:
#   - name: kafka-tls
#     secretName: kafka-secret-elk
#     path: /usr/share/apm-server/config/kafka-tls
#     defaultMode: 0400

# Zmienne (tokeny/hasła z Secretów)
env: []
envFrom: []
# Przykład (sekrety z tokenami/hasłami):
# envFrom:
#   - secretRef: { name: apm-env-secrets }

serviceAccount:
  create: false
  annotations: {}
  name: ""

podAnnotations: {}
podLabels: {}

podSecurityContext:
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault

securityContext:
  runAsNonRoot: true
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true

service:
  type: ClusterIP
  port: 8200
  annotations: {}

resources:
  requests:
    cpu: 200m
    memory: 512Mi
  limits:
    cpu: 1
    memory: 1Gi

nodeSelector: {}
tolerations: []
affinity: {}

livenessProbe:
  httpGet:
    path: /
    port: 8200
  initialDelaySeconds: 20
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /
    port: 8200
  initialDelaySeconds: 5
  periodSeconds: 5

# Dodatki (opcjonalnie: extraVolumes/extraContainers np. sidecar /metrics)
extraVolumes: []
extraVolumeMounts: []
extraContainers: []
```

offline/apm-server/templates/_helpers.tpl
```yaml
{{- define "apm-server.name" -}}
{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix "-" -}}
{{- end -}}

{{- define "apm-server.fullname" -}}
{{- if .Values.fullnameOverride -}}
{{- .Values.fullnameOverride | trunc 63 | trimSuffix "-" -}}
{{- else -}}
{{- $name := include "apm-server.name" . -}}
{{- if .Release.Name }}{{ printf "%s-%s" .Release.Name $name | trunc 63 | trimSuffix "-" }}{{ else }}{{ $name }}{{ end -}}
{{- end -}}
{{- end -}}
```

offline/apm-server/templates/configmap.yaml
```yaml
{{- if .Values.apmConfig }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "apm-server.fullname" . }}-config
  labels:
    app.kubernetes.io/name: {{ include "apm-server.name" . }}
    app.kubernetes.io/instance: {{ .Release.Name }}
data:
{{- range $k, $v := .Values.apmConfig }}
  {{ $k }}: |
{{ $v | indent 4 }}
{{- end }}
{{- end }}
```

offline/apm-server/templates/deployment.yaml
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "apm-server.fullname" . }}
  labels:
    app.kubernetes.io/name: {{ include "apm-server.name" . }}
    app.kubernetes.io/instance: {{ .Release.Name }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app.kubernetes.io/name: {{ include "apm-server.name" . }}
      app.kubernetes.io/instance: {{ .Release.Name }}
  template:
    metadata:
      labels:
        app.kubernetes.io/name: {{ include "apm-server.name" . }}
        app.kubernetes.io/instance: {{ .Release.Name }}
        {{- with .Values.podLabels }}{{ toYaml . | nindent 8 }}{{- end }}
      {{- with .Values.podAnnotations }}
      annotations:
{{ toYaml . | indent 8 }}
      {{- end }}
    spec:
      {{- if .Values.serviceAccount.create }}
      serviceAccountName: {{ include "apm-server.fullname" . }}
      {{- else if .Values.serviceAccount.name }}
      serviceAccountName: {{ .Values.serviceAccount.name }}
      {{- end }}
      securityContext:
{{ toYaml .Values.podSecurityContext | indent 8 }}
      volumes:
      {{- if .Values.apmConfig }}
      - name: apm-config
        configMap:
          name: {{ include "apm-server.fullname" . }}-config
      {{- end }}
      {{- range .Values.secretMounts }}
      - name: {{ .name }}
        secret:
          secretName: {{ .secretName }}
          {{- if .defaultMode }}
          defaultMode: {{ .defaultMode }}
          {{- end }}
      {{- end }}
      {{- if .Values.extraVolumes }}
{{ toYaml .Values.extraVolumes | indent 6 }}
      {{- end }}
      containers:
      - name: apm-server
        image: "{{ .Values.image }}:{{ .Values.imageTag }}"
        imagePullPolicy: {{ .Values.imagePullPolicy }}
        securityContext:
{{ toYaml .Values.securityContext | indent 10 }}
        ports:
        - name: http
          containerPort: 8200
          protocol: TCP
        env:
        {{- range .Values.env }}
        - {{- toYaml . | nindent 10 }}
        {{- end }}
        {{- if .Values.envFrom }}
        envFrom:
{{ toYaml .Values.envFrom | indent 10 }}
        {{- end }}
        volumeMounts:
        {{- if .Values.apmConfig }}
        - name: apm-config
          mountPath: /usr/share/apm-server/apm-server.yml
          subPath: apm-server.yml
          readOnly: true
        {{- end }}
        {{- range .Values.secretMounts }}
        - name: {{ .name }}
          mountPath: {{ .path }}
          readOnly: true
        {{- end }}
        {{- if .Values.extraVolumeMounts }}
{{ toYaml .Values.extraVolumeMounts | indent 10 }}
        {{- end }}
        livenessProbe:
{{ toYaml .Values.livenessProbe | indent 10 }}
        readinessProbe:
{{ toYaml .Values.readinessProbe | indent 10 }}
        resources:
{{ toYaml .Values.resources | indent 10 }}
      {{- if .Values.extraContainers }}
{{ toYaml .Values.extraContainers | indent 6 }}
      {{- end }}
      {{- if .Values.imagePullSecrets }}
      imagePullSecrets:
{{ toYaml .Values.imagePullSecrets | indent 8 }}
      {{- end }}
      nodeSelector:
{{ toYaml .Values.nodeSelector | indent 8 }}
      tolerations:
{{ toYaml .Values.tolerations | indent 8 }}
      affinity:
{{ toYaml .Values.affinity | indent 8 }}
```

offline/apm-server/templates/service.yaml
```yaml
apiVersion: v1
kind: Service
metadata:
  name: {{ include "apm-server.fullname" . }}
  labels:
    app.kubernetes.io/name: {{ include "apm-server.name" . }}
    app.kubernetes.io/instance: {{ .Release.Name }}
  {{- with .Values.service.annotations }}
  annotations:
{{ toYaml . | indent 4 }}
  {{- end }}
spec:
  type: {{ .Values.service.type }}
  selector:
    app.kubernetes.io/name: {{ include "apm-server.name" . }}
    app.kubernetes.io/instance: {{ .Release.Name }}
  ports:
  - name: http
    port: {{ .Values.service.port }}
    targetPort: 8200
    protocol: TCP
```

offline/apm-server/templates/serviceaccount.yaml
```yaml
{{- if .Values.serviceAccount.create }}
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ include "apm-server.fullname" . }}
  labels:
    app.kubernetes.io/name: {{ include "apm-server.name" . }}
    app.kubernetes.io/instance: {{ .Release.Name }}
{{- end }}
```

offline/apm-server/templates/NOTES.txt
```txt
APM Server {{ .Chart.AppVersion }} zainstalowany.
Service: {{ include "apm-server.fullname" . }}:{{ .Values.service.port }}

Sprawdź logi:
  kubectl -n {{ .Release.Namespace }} logs deploy/{{ include "apm-server.fullname" . }}
```

3) Przygotuj obraz apm-server:8.14.3 offline
Na maszynie z internetem:
```bash
docker pull docker.elastic.co/apm/apm-server:8.14.3
docker save -o apm-server-8.14.3.tar docker.elastic.co/apm/apm-server:8.14.3
```
W środowisku bez internetu (ale z wewnętrznym registry):
```bash
docker load -i apm-server-8.14.3.tar
docker tag docker.elastic.co/apm/apm-server:8.14.3 registry.local/elastic/apm-server:8.14.3
docker push registry.local/elastic/apm-server:8.14.3
```
W values.yaml ustaw:
- image: registry.local/elastic/apm-server
- imageTag: 8.14.3
- ewentualnie imagePullSecrets: [{name: regcred}]

4) Utwórz Secrety (jeśli jeszcze nie istnieją)

A) TLS do Kafki (PEM) – w Twoim namespace:
```bash
kubectl -n observability create secret generic kafka-secret-elk \
  --from-file=ca-bungle.crt=./ca-bungle.crt \
  --from-file=tls-bungle.crt=./tls-bungle.crt \
  --from-file=tls.key=./tls.key
```
W values.yaml odkomentuj secretMounts:
```yaml
secretMounts:
  - name: kafka-tls
    secretName: kafka-secret-elk
    path: /usr/share/apm-server/config/kafka-tls
    defaultMode: 0400
```

B) (Zamiennie) PKCS#12/JKS – stwórz Secret z plikiem i hasłem:
```bash
kubectl -n observability create secret generic apm-kafka-keystore \
  --from-file=client.p12=./client.p12
kubectl -n observability create secret generic apm-env-secrets \
  --from-literal=KS_PASS='twojeHaslo'
```
W values.yaml podmień sekcję output.kafka na PKCS#12/JKS i dodaj envFrom:
```yaml
envFrom:
  - secretRef: { name: apm-env-secrets }
secretMounts:
  - name: kafka-tls
    secretName: apm-kafka-keystore
    path: /usr/share/apm-server/config/kafka-tls
    defaultMode: 0400
```

C) (Opcjonalnie) token do intake:
```bash
kubectl -n observability create secret generic apm-env-secrets \
  --from-literal=APM_SECRET_TOKEN='sekret' \
  --from-literal=KAFKA_USERNAME='user' \
  --from-literal=KAFKA_PASSWORD='pass'
```
I w values.yaml:
```yaml
envFrom:
  - secretRef: { name: apm-env-secrets }
```

D) (Opcjonalnie) pull secret do Waszego registry:
```bash
kubectl -n observability create secret docker-registry regcred \
  --docker-server=registry.local \
  --docker-username=USER --docker-password=PASS --docker-email=devnull@example.com
```
I w values.yaml:
```yaml
imagePullSecrets: [{ name: regcred }]
```

5) Instalacja Helm (air‑gapped)
```bash
helm upgrade --install apm-server ./offline/apm-server \
  -n observability --create-namespace \
  -f ./offline/apm-server/values.yaml
```

6) Weryfikacja i debug
- Pod’y:
```bash
kubectl -n observability get pods -l app.kubernetes.io/name=apm-server
```
- Logi:
```bash
kubectl -n observability logs deploy/apm-server
```
- Szybki test output (TLS WARN dla Kafki jest normalny – ważny jest exit code=0):
```bash
kubectl -n observability exec deploy/apm-server -- \
  apm-server test output -c /usr/share/apm-server/apm-server.yml
```

7) Zmiana na SASL lub PKCS#12/JKS
- SASL: w values.yaml odkomentuj username/password/sasl.mechanism, dodaj envFrom z Secretu zawierającego KAFKA_USERNAME/KAFKA_PASSWORD, usuń ssl.certificate/ssl.key.
- PKCS#12/JKS: jak w pkt 4B – podmień ścieżki i hasła; Secret z keystore zamontuj w secretMounts.

8) OpenShift (uwagi)
- Chart ma runAsNonRoot + readOnlyRootFilesystem – zgodny z restricted SCC.
- Pliki Secretów są montowane tylko do odczytu (defaultMode: 0400).
- Jeśli macie limitacje na obrazy, upewnij się, że registry.local jest dostępny z OCP i że masz poprawny imagePullSecret.

Masz inne ścieżki/nazwy Secretów/adresy brokerów? Wklej je, a przygotuję gotowy values.yaml 1:1 (i ewentualnie manifesty Secretów).
