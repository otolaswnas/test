scrape_configs:
  - job_name: 'app1'
    scrape_interval: 5s
    static_configs:
      - targets: ['localhost:9091']
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
        replacement: app1
    basic_auth:
      username: 'user1'
      password: 'password1'

  - job_name: 'app2'
    scrape_interval: 5s
    static_configs:
      - targets: ['localhost:9092']
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
        replacement: app2
    basic_auth:
      username: 'user2'
      password: 'password2'

--------------------------------------
http {
    server {
        listen 9091;
        server_name app1;

        location / {
            proxy_pass http://localhost:9091;
            auth_basic "Restricted Content";
            auth_basic_user_file /etc/nginx/.htpasswd_app1;
        }
    }

    server {
        listen 9092;
        server_name app2;

        location / {
            proxy_pass http://localhost:9092;
            auth_basic "Restricted Content";
            auth_basic_user_file /etc/nginx/.htpasswd_app2;
        }
    }
}

-------------------------------------------------------
https://www.elastic.co/guide/en/elasticsearch/reference/8.8/logging.html
-------------------------------------------------------
/var/log/elasticsearch/crlo-*audit*json.gz {
    daily
    missingok
    nocompress
    notifempty
    create 640 root adm
    postrotate
        find /var/log/elasticsearch/ -name "crlo-*audit*json.gz" -mtime +3 -delete
    endscript
}


------------
curl -X GET "http://localhost:5601/api/saved_objects/_find?type=index-pattern&space_id=nazwa_space" -H 'kbn-xsrf: true'

-----------------------------
Aby doda nowy indeks do `indices names` dla danej roli w Elasticsearch, mo偶esz najpierw pobra aktualn list indeks贸w, a nastpnie doda nowy indeks do tej listy i zaktualizowa rol za pomoc polecenia `curl`. Poni偶ej znajduje si przykadowy skrypt bash, kt贸ry wykonuje te zadania:

```bash
# Wykonaj polecenie curl i zapisz wynik do zmiennej
rola="twoja_rola"
wynik=$(curl -X GET "localhost:9200/_security/role/$rola")

# U偶yj jq, aby przetworzy wynik i uzyska dostp do indices names
indices_names=$(echo "$wynik" | jq -r ".[\"$rola\"].indices")

# Dodaj nowy indeks do listy
nowy_indeks="twoj_nowy_indeks"
zmienione_indices_names=$(echo "$indices_names" | jq ". += [\"$nowy_indeks\"]")

# Zaktualizuj rol za pomoc zmienionej listy indeks贸w
zmieniona_rola=$(echo "$wynik" | jq ".[\"$rola\"].indices = $zmienione_indices_names")
curl -X PUT "localhost:9200/_security/role/$rola" -H 'Content-Type: application/json' -d"$zmieniona_rola"
```

W tym skrypcie, `. += [\"$nowy_indeks\"]` to wyra偶enie `jq`, kt贸re dodaje nowy indeks do listy indeks贸w. Nastpnie `.indices = $zmienione_indices_names` aktualizuje list indeks贸w dla danej roli.

Pamitaj, 偶e musisz zastpi `"localhost:9200"`, `"twoja_rola"` i `"twoj_nowy_indeks"` odpowiednimi wartociami. Jeli Tw贸j klaster Elasticsearch jest zabezpieczony, musisz r贸wnie偶 dostarczy odpowiednie dane uwierzytelniajce z 偶daniem `curl`.

Mam nadziej, 偶e to pomo偶e! Jeli masz jakiekolwiek pytania lub potrzebujesz dalszej pomocy, daj mi zna! 
--------------------------------------------------------------
# Wykonaj polecenie curl i zapisz wynik do zmiennej
wynik=$(curl -X GET "localhost:9200/_security/role" | jq -r 'keys | .[]')

# U偶yj ptli while do odczytywania wynik贸w linia po linii
echo "$wynik" | while read -r rola
do
   echo "$rola"
done

----------------------------------------------------
# Wykonaj polecenie curl i zapisz wynik do zmiennej
wynik=$(curl -X GET "localhost:9200/_security/role" | jq -r 'keys[]')

# U偶yj IFS (Internal Field Separator) do podziau wyniku na tablic
IFS=$'\n' read -r -a tablica <<< "$wynik"

# Wywietl ka偶dy element tablicy
for rola in "${tablica[@]}"
do
   echo "$rola"
done


------------------------------------
# Wykonaj polecenie curl i zapisz wynik do zmiennej
wynik=$(curl -s 'http://twojastrona.com')

# U偶yj IFS (Internal Field Separator) do podziau wyniku na tablic
IFS=' ' read -r -a tablica <<< "$wynik"

# Wywietl ka偶dy element tablicy
for element in "${tablica[@]}"
do
   echo "$element"
done

-------------

while read -r line; do
    indices=$(echo $line | grep -oP '(?<="indices":{").*?(?=")')
    storage_size=$(echo $line | grep -oP '(?<=storage.size: ).*?(?= )')
    pri_storage_size=$(echo $line | grep -oP '(?<=pri.storage.size: ).*')
    echo "Indices: $indices"
    echo "Storage size: $storage_size"
    echo "Primary storage size: $pri_storage_size"
done < input.txt
-----------------
script:
  - if [[ $fileList == *"plik1"* ]]; then
      ls -la;
    elif [[ $fileList == *"plik2"* ]]; then
      ls -ltr;
    fi

----------------------------------------
- name: Utw贸rz katalog jeli nie istnieje
      file:
        path: /cie偶ka/do/katalogu
        state: directory
-------------------------------
- name: Zarchiwizuj istniejce pliki
      copy:
        src: "/lokalizacja/sprawdz/{{ item.item }}"
        dest: "/backup/{{ item.item }}.bak"
        remote_src: yes
      when: item.stat.exists
      loop: "{{ files_stat.results }}"

    - name: Skopiuj nowe pliki do katalogu /lokalizacja/sprawdz
      copy:
        src: "/example/folder/{{ item }}"
        dest: "/lokalizacja/sprawdz/{{ item }}"
      loop: "{{ files_list }}"
---------------------------------------
- FILES=$(echo '['$(ls -1 /example/folder | sed 's/^/"/;s/$/"/' | paste -sd, -)']')
--------------------
dc1_array = [["c7.cluster.pl", "c8.cluster.pl"]]
dc2_array = [["d7.cluster.pl"]]

def check_element(element):
    # Spaszczanie list wewntrznych
    dc1_flat = [item for sublist in dc1_array for item in sublist]
    dc2_flat = [item for sublist in dc2_array for item in sublist]

    if element in dc1_flat:
        print(f"{element} znajduje si w dc1_array")
    elif element in dc2_flat:
        print(f"{element} znajduje si w dc2_array")
    else:
        print(f"{element} nie znajduje si ani w dc1_array, ani w dc2_array")

# Przykadowe u偶ycie funkcji
check_element("c7.cluster.pl")
check_element("d7.cluster.pl")
check_element("c9.cluster.pl")

------------------------
CLUSTER_ARRAY = [["c7.cluster.pl", "c8.cluster.pl"], ["d7.cluster.pl"]]
dc1_array = [["c7.cluster.pl", "c8.cluster.pl"]]
dc2_array = [["d7.cluster.pl"]]

# Spaszczanie list wewntrznych
dc1_flat = [item for sublist in dc1_array for item in sublist]
dc2_flat = [item for sublist in dc2_array for item in sublist]

# Iteracja po licie list
for cluster in CLUSTER_ARRAY:
    for server in cluster:
        if server in dc1_flat:
            print(f"{server} znajduje si w dc1_array")
        elif server in dc2_flat:
            print(f"{server} znajduje si w dc2_array")
        else:
            print(f"{server} nie znajduje si ani w dc1_array, ani w dc2_array")

------------------------------------------------------------------------------
job1:
  variables:
    CLUSTER_LIST: '[["c7.cluster.pl", "c8.cluster.pl"], ["d7.cluster.pl"]]'
  script:
    - python3 my_script.py


import os
import json

cluster_list = json.loads(os.environ['CLUSTER_LIST'])

for cluster in cluster_list:
    for server in cluster:
        print(server)

--------------------------------------------------------------------
ifArray = [[["pole", "-eq", "warto", "and"],
            ["pole", "-eq", "warto", "and"],
            ["pole", "-eq", "warto"]],
           [["pole", "-eq", "warto", "and"],
            ["pole", "-eq", "warto"]],
           [["pole", "-eq", "warto"]]]

for i in range(len(ifArray)):
    for j in range(len(ifArray[i])):
        for k in range(len(ifArray[i][j])):
            print(f"ifArray[{i}][{j}][{k}] = {ifArray[i][j][k]}")
------------------------
declare -A my_array
my_array=(["key1:subkey1"]="value1" ["key1:subkey2"]="value2" ["key2:subkey1"]="value3")

# Iteracja po kluczach tablicy asocjacyjnej za pomoc ptli for
for key in "${!my_array[@]}"
do
    # Podzia klucza na czci
    IFS=':' read -ra key_parts <<< "$key"
    # Wypisanie klucza i wartoci
    echo "${key_parts[0]}, ${key_parts[1]}: ${my_array[$key]}"
done
-------
#!/bin/bash

declare -A ifArray

ifArray[0,0,0]="pole"
ifArray[0,0,1]="-eq"
ifArray[0,0,2]="warto"
ifArray[0,0,3]="and"

ifArray[0,1,0]="pole"
ifArray[0,1,1]="-eq"
ifArray[0,1,2]="warto"
ifArray[0,1,3]="and"

ifArray[0,2,0]="pole"
ifArray[0,2,1]="-eq"
ifArray[0,2,2]="warto"
ifArray[0,2,3]=""

ifCondition="if [ "
for ((i=0;i<${#ifArray[@]};i++)); do
    for ((j=0;j<${#ifArray[$i]};j++)); do
        ifCondition+="${ifArray[$i,$j,$j]} ${ifArray[$i,$j,$j+1]} ${ifArray[$i,$j,$j+2]}"
        if [[ "${ifArray[$i,$j,$j+3]}" != "" ]]; then
            ifCondition+=" ] ${ifArray[$i,$j,$j+3]} [ "
        fi
    done
done
ifCondition+=" ]; then echo 'Warunek speniony'; else echo 'Warunek niespeniony'; fi"

eval $ifCondition


-----
declare -A ifArray

ifArray[0,0,0]="pole"
ifArray[0,0,1]="-eq"
ifArray[0,0,2]="warto"
ifArray[0,0,3]="and"

ifArray[0,1,0]="pole"
ifArray[0,1,1]="-eq"
ifArray[0,1,2]="warto"
ifArray[0,1,3]="and"

ifArray[0,2,0]="pole"
ifArray[0,2,1]="-eq"
ifArray[0,2,2]="warto"
ifArray[0,2,3]=""

ifCondition="if [ "
for ((i=0;i<${#ifArray[@]};i++)); do
    ifCondition+="${ifArray[$i,$i,$i]} ${ifArray[$i,$i,$i+1]} ${ifArray[$i,$i,$i+2]}"
    if [[ "${ifArray[$i,$i,$i+3]}" != "" ]]; then
        ifCondition+=" ] ${ifArray[$i,$i,$i+3]} [ "
    fi
done
ifCondition+=" ]; then echo 'Warunek speniony'; else echo 'Warunek niespeniony'; fi"

eval $ifCondition
---------------
#!/bin/bash

matchingField[0][0]="pole"
condition[0][0]="-eq"
pattern[0][0]="warto"
rule[0][0]="and"
matchingField[0][1]="pole"
condition[0][1]="-eq"
pattern[0][1]="warto"
rule[0][1]="and"
matchingField[0][2]="pole"
condition[0][2]="-eq"
pattern[0][2]="warto"
rule[0][2]=""

matchingField[1][0]="pole"
condition[1][0]="-eq"
pattern[1][0]="warto"
rule[1][0]="and"
matchingField[1][1]="pole"
condition[1][1]="-eq"
pattern[1][1]="warto"
rule[1][1]="and"
matchingField[1][2]="pole"
condition[1][2]="-eq"
pattern[1][2]="warto"
rule[1][2]=""

matchingField[2][0]="pole"
condition[2][0]="-eq"
pattern[2][0]="warto"
rule[2][0]="and"
matchingField[2][1]="pole"
condition[2][1]="-eq"
pattern[2][1]="warto"
rule[2][1]=""

matchingField[3][0]="pole"
condition[3][0]="-eq"
pattern[3][0]="warto"
rule[3][0]=""


ifCondition="if [ "
for ((i=0;i<${#matchingField[@]};i++)); do
    for ((j=0;j<${#matchingField[$i]};j++)); do
        ifCondition+="${matchingField[$i][$j]} ${condition[$i][$j]} ${pattern[$i][$j]}"
        if [[ "${rule[$i][$j]}" != "" ]]; then
            ifCondition+=" ] ${rule[$i][$j]} [ "
        fi
    done
    if [[ $i -lt $((${#matchingField[@]} - 1)) ]]; then
        ifCondition+=" ] || [ "
    fi
done
ifCondition+=" ]; then echo 'Warunek speniony'; else echo 'Warunek niespeniony'; fi"

eval $ifCondition
--------------------------------------
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "field1": "value1"
          }
        },
        {
          "match": {
            "field2": {
              "query": "value2",
              "fuzziness": "AUTO"
            }
          }
        }
      ]
    }
  }
}

---------------------
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "field1": "value1"
          }
        },
        {
          "wildcard": {
            "field2": "*value2*"
          }
        }
      ]
    }
  }
}

---------------------------------------------------------------
GET /_search
{
  "query": {
    "bool": {
      "must": [
        {
          "wildcard": {
            "field1": "*value1*"
          }
        },
        {
          "wildcard": {
            "field2": "*value2*"
          }
        }
      ]
    }
  }
}
----------------------
GET /_search
{
  "query": {
    "bool": {
      "must": [
        {
          "wildcard": {
            "field1": "*value1*"
          }
        },
        {
          "wildcard": {
            "field2": "*value2*"
          }
        }
      ]
    }
  }
}



####################################################################33
#!/bin/bash

file1="file1.txt"
file2="file2.txt"

echo "Linie z $file1, kt贸re nie maj dopasowania w $file2:"
while read -r line1; do
  match=0
  while read -r line2; do
    if [[ "$line1" == "$line2" ]]; then
      match=1
      break
    fi
  done < "$file2"
  if [[ $match -eq 0 ]]; then
    echo "$line1"
  fi
done < "$file1"

echo "Linie z $file2, kt贸re nie maj dopasowania w $file1:"
while read -r line2; do
  match=0
  while read -r line1; do
    if [[ "$line2" == "$line1" ]]; then
      match=1
      break
    fi
  done < "$file1"
  if [[ $match -eq 0 ]]; then
    echo "$line2"
  fi
done < "$file2"
