# Wykonaj polecenie curl i zapisz wynik do zmiennej
wynik=$(curl -X GET "localhost:9200/_security/role" | jq -r 'keys[]')

# Użyj IFS (Internal Field Separator) do podziału wyniku na tablicę
IFS=$'\n' read -r -a tablica <<< "$wynik"

# Wyświetl każdy element tablicy
for rola in "${tablica[@]}"
do
   echo "$rola"
done


------------------------------------
# Wykonaj polecenie curl i zapisz wynik do zmiennej
wynik=$(curl -s 'http://twojastrona.com')

# Użyj IFS (Internal Field Separator) do podziału wyniku na tablicę
IFS=' ' read -r -a tablica <<< "$wynik"

# Wyświetl każdy element tablicy
for element in "${tablica[@]}"
do
   echo "$element"
done

-------------

while read -r line; do
    indices=$(echo $line | grep -oP '(?<="indices":{").*?(?=")')
    storage_size=$(echo $line | grep -oP '(?<=storage.size: ).*?(?= )')
    pri_storage_size=$(echo $line | grep -oP '(?<=pri.storage.size: ).*')
    echo "Indices: $indices"
    echo "Storage size: $storage_size"
    echo "Primary storage size: $pri_storage_size"
done < input.txt
-----------------
script:
  - if [[ $fileList == *"plik1"* ]]; then
      ls -la;
    elif [[ $fileList == *"plik2"* ]]; then
      ls -ltr;
    fi

----------------------------------------
- name: Utwórz katalog jeśli nie istnieje
      file:
        path: /ścieżka/do/katalogu
        state: directory
-------------------------------
- name: Zarchiwizuj istniejące pliki
      copy:
        src: "/lokalizacja/sprawdz/{{ item.item }}"
        dest: "/backup/{{ item.item }}.bak"
        remote_src: yes
      when: item.stat.exists
      loop: "{{ files_stat.results }}"

    - name: Skopiuj nowe pliki do katalogu /lokalizacja/sprawdz
      copy:
        src: "/example/folder/{{ item }}"
        dest: "/lokalizacja/sprawdz/{{ item }}"
      loop: "{{ files_list }}"
---------------------------------------
- FILES=$(echo '['$(ls -1 /example/folder | sed 's/^/"/;s/$/"/' | paste -sd, -)']')
--------------------
dc1_array = [["c7.cluster.pl", "c8.cluster.pl"]]
dc2_array = [["d7.cluster.pl"]]

def check_element(element):
    # Spłaszczanie list wewnętrznych
    dc1_flat = [item for sublist in dc1_array for item in sublist]
    dc2_flat = [item for sublist in dc2_array for item in sublist]

    if element in dc1_flat:
        print(f"{element} znajduje się w dc1_array")
    elif element in dc2_flat:
        print(f"{element} znajduje się w dc2_array")
    else:
        print(f"{element} nie znajduje się ani w dc1_array, ani w dc2_array")

# Przykładowe użycie funkcji
check_element("c7.cluster.pl")
check_element("d7.cluster.pl")
check_element("c9.cluster.pl")

------------------------
CLUSTER_ARRAY = [["c7.cluster.pl", "c8.cluster.pl"], ["d7.cluster.pl"]]
dc1_array = [["c7.cluster.pl", "c8.cluster.pl"]]
dc2_array = [["d7.cluster.pl"]]

# Spłaszczanie list wewnętrznych
dc1_flat = [item for sublist in dc1_array for item in sublist]
dc2_flat = [item for sublist in dc2_array for item in sublist]

# Iteracja po liście list
for cluster in CLUSTER_ARRAY:
    for server in cluster:
        if server in dc1_flat:
            print(f"{server} znajduje się w dc1_array")
        elif server in dc2_flat:
            print(f"{server} znajduje się w dc2_array")
        else:
            print(f"{server} nie znajduje się ani w dc1_array, ani w dc2_array")

------------------------------------------------------------------------------
job1:
  variables:
    CLUSTER_LIST: '[["c7.cluster.pl", "c8.cluster.pl"], ["d7.cluster.pl"]]'
  script:
    - python3 my_script.py


import os
import json

cluster_list = json.loads(os.environ['CLUSTER_LIST'])

for cluster in cluster_list:
    for server in cluster:
        print(server)

--------------------------------------------------------------------
ifArray = [[["pole", "-eq", "wartość", "and"],
            ["pole", "-eq", "wartość", "and"],
            ["pole", "-eq", "wartość"]],
           [["pole", "-eq", "wartość", "and"],
            ["pole", "-eq", "wartość"]],
           [["pole", "-eq", "wartość"]]]

for i in range(len(ifArray)):
    for j in range(len(ifArray[i])):
        for k in range(len(ifArray[i][j])):
            print(f"ifArray[{i}][{j}][{k}] = {ifArray[i][j][k]}")
------------------------
declare -A my_array
my_array=(["key1:subkey1"]="value1" ["key1:subkey2"]="value2" ["key2:subkey1"]="value3")

# Iteracja po kluczach tablicy asocjacyjnej za pomocą pętli for
for key in "${!my_array[@]}"
do
    # Podział klucza na części
    IFS=':' read -ra key_parts <<< "$key"
    # Wypisanie klucza i wartości
    echo "${key_parts[0]}, ${key_parts[1]}: ${my_array[$key]}"
done
-------
#!/bin/bash

declare -A ifArray

ifArray[0,0,0]="pole"
ifArray[0,0,1]="-eq"
ifArray[0,0,2]="wartość"
ifArray[0,0,3]="and"

ifArray[0,1,0]="pole"
ifArray[0,1,1]="-eq"
ifArray[0,1,2]="wartość"
ifArray[0,1,3]="and"

ifArray[0,2,0]="pole"
ifArray[0,2,1]="-eq"
ifArray[0,2,2]="wartość"
ifArray[0,2,3]=""

ifCondition="if [ "
for ((i=0;i<${#ifArray[@]};i++)); do
    for ((j=0;j<${#ifArray[$i]};j++)); do
        ifCondition+="${ifArray[$i,$j,$j]} ${ifArray[$i,$j,$j+1]} ${ifArray[$i,$j,$j+2]}"
        if [[ "${ifArray[$i,$j,$j+3]}" != "" ]]; then
            ifCondition+=" ] ${ifArray[$i,$j,$j+3]} [ "
        fi
    done
done
ifCondition+=" ]; then echo 'Warunek spełniony'; else echo 'Warunek niespełniony'; fi"

eval $ifCondition


-----
declare -A ifArray

ifArray[0,0,0]="pole"
ifArray[0,0,1]="-eq"
ifArray[0,0,2]="wartość"
ifArray[0,0,3]="and"

ifArray[0,1,0]="pole"
ifArray[0,1,1]="-eq"
ifArray[0,1,2]="wartość"
ifArray[0,1,3]="and"

ifArray[0,2,0]="pole"
ifArray[0,2,1]="-eq"
ifArray[0,2,2]="wartość"
ifArray[0,2,3]=""

ifCondition="if [ "
for ((i=0;i<${#ifArray[@]};i++)); do
    ifCondition+="${ifArray[$i,$i,$i]} ${ifArray[$i,$i,$i+1]} ${ifArray[$i,$i,$i+2]}"
    if [[ "${ifArray[$i,$i,$i+3]}" != "" ]]; then
        ifCondition+=" ] ${ifArray[$i,$i,$i+3]} [ "
    fi
done
ifCondition+=" ]; then echo 'Warunek spełniony'; else echo 'Warunek niespełniony'; fi"

eval $ifCondition
---------------
#!/bin/bash

matchingField[0][0]="pole"
condition[0][0]="-eq"
pattern[0][0]="wartość"
rule[0][0]="and"
matchingField[0][1]="pole"
condition[0][1]="-eq"
pattern[0][1]="wartość"
rule[0][1]="and"
matchingField[0][2]="pole"
condition[0][2]="-eq"
pattern[0][2]="wartość"
rule[0][2]=""

matchingField[1][0]="pole"
condition[1][0]="-eq"
pattern[1][0]="wartość"
rule[1][0]="and"
matchingField[1][1]="pole"
condition[1][1]="-eq"
pattern[1][1]="wartość"
rule[1][1]="and"
matchingField[1][2]="pole"
condition[1][2]="-eq"
pattern[1][2]="wartość"
rule[1][2]=""

matchingField[2][0]="pole"
condition[2][0]="-eq"
pattern[2][0]="wartość"
rule[2][0]="and"
matchingField[2][1]="pole"
condition[2][1]="-eq"
pattern[2][1]="wartość"
rule[2][1]=""

matchingField[3][0]="pole"
condition[3][0]="-eq"
pattern[3][0]="wartość"
rule[3][0]=""


ifCondition="if [ "
for ((i=0;i<${#matchingField[@]};i++)); do
    for ((j=0;j<${#matchingField[$i]};j++)); do
        ifCondition+="${matchingField[$i][$j]} ${condition[$i][$j]} ${pattern[$i][$j]}"
        if [[ "${rule[$i][$j]}" != "" ]]; then
            ifCondition+=" ] ${rule[$i][$j]} [ "
        fi
    done
    if [[ $i -lt $((${#matchingField[@]} - 1)) ]]; then
        ifCondition+=" ] || [ "
    fi
done
ifCondition+=" ]; then echo 'Warunek spełniony'; else echo 'Warunek niespełniony'; fi"

eval $ifCondition
--------------------------------------
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "field1": "value1"
          }
        },
        {
          "match": {
            "field2": {
              "query": "value2",
              "fuzziness": "AUTO"
            }
          }
        }
      ]
    }
  }
}

---------------------
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "field1": "value1"
          }
        },
        {
          "wildcard": {
            "field2": "*value2*"
          }
        }
      ]
    }
  }
}

---------------------------------------------------------------
GET /_search
{
  "query": {
    "bool": {
      "must": [
        {
          "wildcard": {
            "field1": "*value1*"
          }
        },
        {
          "wildcard": {
            "field2": "*value2*"
          }
        }
      ]
    }
  }
}
----------------------
GET /_search
{
  "query": {
    "bool": {
      "must": [
        {
          "wildcard": {
            "field1": "*value1*"
          }
        },
        {
          "wildcard": {
            "field2": "*value2*"
          }
        }
      ]
    }
  }
}



####################################################################33
#!/bin/bash

file1="file1.txt"
file2="file2.txt"

echo "Linie z $file1, które nie mają dopasowania w $file2:"
while read -r line1; do
  match=0
  while read -r line2; do
    if [[ "$line1" == "$line2" ]]; then
      match=1
      break
    fi
  done < "$file2"
  if [[ $match -eq 0 ]]; then
    echo "$line1"
  fi
done < "$file1"

echo "Linie z $file2, które nie mają dopasowania w $file1:"
while read -r line2; do
  match=0
  while read -r line1; do
    if [[ "$line2" == "$line1" ]]; then
      match=1
      break
    fi
  done < "$file1"
  if [[ $match -eq 0 ]]; then
    echo "$line2"
  fi
done < "$file2"
