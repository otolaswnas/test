curl -X POST "https://twoja-kibana:5601/s/marketing/api/saved_objects/_export" \
  -H "kbn-xsrf: true" \
  -H "Content-Type: application/json" \
  -u user:password \
  -d '{
    "type": ["search"],
    "objects": [
      { "type": "search", "id": "ID_TWOJEGO_SEARCHA" }
    ],
    "includeReferencesDeep": true
  }' -o search_export.json


-d '{"type": ["search"], "includeReferencesDeep": true}'


curl -X POST "https://twoja-kibana:5601/s/it/api/saved_objects/_import?overwrite=true" \
  -H "kbn-xsrf: true" \
  -H "Content-Type: multipart/form-data" \
  -u user:password \
  -F "file=@search_export.json"



Oczywi≈õcie! Poni≈ºej znajdziesz **gotowƒÖ tre≈õƒá e-maila**, kt√≥ry mo≈ºesz wys≈Çaƒá do **GitLab Support** lub zespo≈Çu technicznego GitLaba (np. przez [support.gitlab.com](https://support.gitlab.com/) lub partnerskiego opiekuna technicznego, je≈õli masz wersjƒô Premium/Ultimate).

---

## üìß **Temat (Subject):**  
üìå *Request for GitLab Prometheus Dashboards or Metric Queries for Full Component Monitoring*

---

## üî§ üá¨üáß **Wersja angielska ‚Äî English version**

> Hello GitLab Support Team,  
>
> I‚Äôm using a self-managed GitLab installation running directly on a Linux VM. I have successfully configured Prometheus and exporters for all key GitLab components, including:
> - `node_exporter` (system metrics)
> - `gitlab_workhorse` (port 9229)
> - `gitlab_exporter` (Rails metrics, port 9168)
> - `sidekiq` (port 8082)
> - `redis_exporter` (port 9121)
> - `postgres_exporter` (port 9187)
> - `gitaly` (port 9236)
>
> I understand that GitLab officially no longer provides prebuilt Grafana dashboards for these components (as included previously in the Omnibus or Helm setups), and most community resources have since been removed or deprecated.
>
> **However, these dashboards are still extremely important for full visibility and production-grade monitoring** of a self-hosted GitLab environment.  
>
> Could you please:
>
> 1. Provide me with any existing JSON Grafana dashboards or sample files (even internally used ones)?
> 2. Alternatively, share example PromQL queries and best practices that would allow me to rebuild dashboards manually for:
>     - GitLab Rails
>     - Gitaly
>     - Redis
>     - PostgreSQL
>     - Sidekiq
>     - GitLab Workhorse
>
> I would greatly appreciate your support and any documentation or internal materials you can share.  
>
> Thank you in advance for your help ‚Äì I really wish to keep GitLab monitoring robust and comprehensive.
>
> Kind regards,  
> **[Twoje imiƒô ‚Äî Your Name]**

---

## üáµüá± **Wersja polska ‚Äî Polish version**

> Dzie≈Ñ dobry Zespole GitLab Support,  
>
> Korzystam z instalacji GitLaba w wersji self-managed, uruchomionej bezpo≈õrednio na maszynie z systemem Linux.  
> Uda≈Ço mi siƒô skonfigurowaƒá Prometheusa oraz eksportery metryk dla wszystkich kluczowych komponent√≥w GitLaba, w tym:
>
> - `node_exporter` (metryki systemowe)
> - `gitlab_workhorse` (port 9229)
> - `gitlab_exporter` (Rails ‚Äî port 9168)
> - `sidekiq` (port 8082)
> - `redis_exporter` (port 9121)
> - `postgres_exporter` (port 9187)
> - `gitaly` (port 9236)
>
> Rozumiem, ≈ºe GitLab oficjalnie zaprzesta≈Ç udostƒôpniania gotowych dashboard√≥w Grafany (dostƒôpnych dawniej np. w pakiecie Omnibus lub Helm), a zasoby spo≈Çeczno≈õciowe r√≥wnie≈º zniknƒô≈Çy lub sƒÖ obecnie nieaktywne.
>
> **Jednak takie dashboardy wciƒÖ≈º sƒÖ bardzo wa≈ºne dla pe≈Çnego monitorowania ≈õrodowiska produkcyjnego GitLab.**
>
> Uprzejmie proszƒô o:
>
> 1. Przes≈Çanie gotowych dashboard√≥w Grafany w formacie JSON (nawet je≈õli sƒÖ to materia≈Çy wewnƒôtrzne),
> 2. Alternatywnie: przes≈Çanie przyk≈Çadowych zapyta≈Ñ PromQL oraz dobrych praktyk dotyczƒÖcych monitorowania metryk takich jak:
>    - GitLab Rails
>    - Gitaly
>    - Redis
>    - PostgreSQL
>    - Sidekiq
>    - Workhorse
>
> Bƒôdƒô bardzo wdziƒôczny za ka≈ºdƒÖ pomoc i wszelkie dokumenty lub ≈∫r√≥d≈Ça, kt√≥re mogƒÖ mi pom√≥c w zapewnieniu pe≈Çnego monitoringu ≈õrodowiska GitLab.
>
> Z g√≥ry dziƒôkujƒô.  
> Z powa≈ºaniem,  
> **[Twoje imiƒô]**

---

## ‚úâÔ∏è Gdzie wys≈Çaƒá?

Je≈õli masz wersjƒô **Premium lub Ultimate**, mo≈ºesz:
- wej≈õƒá na [https://support.gitlab.com/](https://support.gitlab.com/) i zalogowaƒá siƒô
- otworzyƒá **support ticket** z powy≈ºszym tekstem
- do≈ÇƒÖczyƒá listƒô swoich komponent√≥w i konfiguracji

W przypadku wersji **Community (CE)** lub self-hosted EE bez wsparcia ‚Äî mo≈ºesz:
- opublikowaƒá pytanie na [https://forum.gitlab.com](https://forum.gitlab.com)
- lub wys≈Çaƒá wiadomo≈õƒá przez formularz kontaktowy z zapytaniem do dzia≈Çu technicznego

---

Je≈õli chcesz ‚Äî mogƒô te≈º pom√≥c:
- przygotowaƒá dashboard ‚Äûod zera‚Äù na podstawie Twoich metryk,
- stworzyƒá szablony zapyta≈Ñ PromQL, kt√≥re wkleisz do Grafany.

Daj znaƒá, je≈õli chcesz i≈õƒá tƒÖ drogƒÖ.
---
- name: Konfiguracja u≈ºytkownika i SSH
  hosts: target_host
  become: true
  vars:
    user_name: "kafka_conf"  # Mo≈ºesz zmieniƒá nazwƒô u≈ºytkownika

  tasks:
    - name: Dodanie u≈ºytkownika
      ansible.builtin.user:
        name: "{{ user_name }}"
        state: present

    - name: Konfiguracja polityki has≈Ça
      ansible.builtin.command:
        cmd: "chage -I -1 -m 0 -M 99999 -E -1 {{ user_name }}"

    - name: Tworzenie katalogu .ssh je≈õli nie istnieje
      ansible.builtin.file:
        path: "/home/{{ user_name }}/.ssh"
        state: directory
        owner: "{{ user_name }}"
        group: "{{ user_name }}"
        mode: '0700'

    - name: Pobranie klucza SSH u≈ºytkownika, z kt√≥rego siƒô ≈ÇƒÖczƒô
      ansible.builtin.set_fact:
        ssh_key: "{{ lookup('file', lookup('env', 'HOME') + '/.ssh/id_rsa.pub') }}"

    - name: Kopiowanie klucza SSH do authorized_keys
      ansible.builtin.copy:
        content: "{{ ssh_key }}"
        dest: "/home/{{ user_name }}/.ssh/authorized_keys"
        owner: "{{ user_name }}"
        group: "{{ user_name }}"
        mode: '0600'

    - name: Dodanie u≈ºytkownika do sudoers
      ansible.builtin.lineinfile:
        path: "/etc/sudoers.d/{{ user_name }}"
        line: "{{ user_name }} ALL=NOPASSWD: /var/lib/kafka/kafka"
        create: true
        mode: '0440'


----------------------------------------------------------------------------------------------
[redhat_servers]
server1.example.com ansible_user=root ansible_ssh_private_key_file=~/.ssh/id_rsa
server2.example.com ansible_user=root ansible_ssh_private_key_file=~/.ssh/id_rsa

#####################3
[Unit]
Description=Node Exporter
Wants=network-online.target
After=network-online.target

[Service]
User=node_exporter
Group=node_exporter
ExecStart=/usr/bin/node_exporter --web.listen-address={{ node_exporter_listen_address }}
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target

#########33
---
- name: Instalacja i konfiguracja Node Exporter na systemach Red Hat
  hosts: redhat_servers
  become: yes
  vars:
    # Parametryzacja: adres, na kt√≥rym bƒôdzie nas≈Çuchiwa≈Ç Node Exporter
    node_exporter_listen_address: "0.0.0.0:9100"
    # Lokalizacja tymczasowego pliku repo dla Prometheusa
    prometheus_repo_file: /etc/yum.repos.d/prometheus.repo
  tasks:
    - name: Dodaj tymczasowe repozytorium Prometheus
      copy:
        dest: "{{ prometheus_repo_file }}"
        content: |
          [prometheus]
          name=Prometheus RPM Repo
          baseurl=https://packagecloud.io/prometheus-rpm/release/el/7/$basearch
          enabled=1
          gpgcheck=1
          repo_gpgcheck=1
          gpgkey=https://packagecloud.io/prometheus-rpm/release/gpg
        owner: root
        group: root
        mode: "0644"
      notify:
        - Clean Yum Cache

    - name: Instalacja pakietu node_exporter
      yum:
        name: node_exporter
        state: present

    - name: Usu≈Ñ tymczasowe repozytorium Prometheus
      file:
        path: "{{ prometheus_repo_file }}"
        state: absent
      notify:
        - Clean Yum Cache

    - name: Konfiguracja systemdowego pliku serwisu Node Exporter
      template:
        src: templates/node_exporter.service.j2
        dest: /etc/systemd/system/node_exporter.service
        owner: root
        group: root
        mode: "0644"
      notify:
        - Reload systemd daemon

    - name: W≈ÇƒÖczenie i uruchomienie serwisu Node Exporter
      systemd:
        name: node_exporter
        enabled: yes
        state: restarted

  handlers:
    - name: Clean Yum Cache
      command: yum clean all

    - name: Reload systemd daemon
      command: systemctl daemon-reload




-----------------------------
image:
  repository: docker.elastic.co/apm/apm-server
  tag: 8.5.1

elasticsearchHosts: "http://elasticsearch:9200"

apmConfig:
  apm-server.yml: |
    apm-server:
      host: "0.0.0.0:8200"
    output.elasticsearch:
      hosts: ["http://elasticsearch:9200"]

service:
  type: ClusterIP
  port: 8200

-----------
#!/bin/bash

LDAP_SERVER="ldaps://your-ad-server:636"  # U≈ºycie SSL na porcie 636
BIND_DN="cn=admin,dc=yourdomain,dc=com"
BIND_PW="yourpassword"
BASE_DN="ou=Groups,dc=yourdomain,dc=com"
FILTER="(cn=*crlo_evt*)"

# Pobierz grupy zgodne z maskƒÖ *_crlo_evt_*
groups=$(ldapsearch -x -H "$LDAP_SERVER" -D "$BIND_DN" -w "$BIND_PW" -b "$BASE_DN" "$FILTER" cn | grep "^cn:" | awk '{print $2}')

# Inicjalizacja zmiennej do przechowywania sumy cz≈Çonk√≥w
total_members=0

# Iteruj przez ka≈ºdƒÖ grupƒô i policz cz≈Çonk√≥w
for group in $groups; do
    members=$(ldapsearch -x -H "$LDAP_SERVER" -D "$BIND_DN" -w "$BIND_PW" -b "$BASE_DN" "(cn=$group)" member | grep "^member:" | wc -l)
    echo "Group: $group, Members: $members"
    total_members=$((total_members + members))
done

# Wy≈õwietl sumƒô cz≈Çonk√≥w dla wszystkich grup
echo "Total Members in all matching groups: $total_members"

-----------
#!/bin/bash

LDAP_SERVER="ldap://your-ad-server"
BIND_DN="cn=admin,dc=yourdomain,dc=com"
BIND_PW="yourpassword"
BASE_DN="ou=Groups,dc=yourdomain,dc=com"
FILTER="(cn=*crlo_evt*)"

# Pobierz grupy zgodne z maskƒÖ *_crlo_evt_*
groups=$(ldapsearch -x -H "$LDAP_SERVER" -D "$BIND_DN" -w "$BIND_PW" -b "$BASE_DN" "$FILTER" cn | grep "^cn:" | awk '{print $2}')

# Iteruj przez ka≈ºdƒÖ grupƒô i policz cz≈Çonk√≥w
for group in $groups; do
    members=$(ldapsearch -x -H "$LDAP_SERVER" -D "$BIND_DN" -w "$BIND_PW" -b "$BASE_DN" "(cn=$group)" member | grep "^member:" | wc -l)
    echo "Group: $group, Members: $members"
done


--------------------------------------------------------------------------------------------------------
parse-json | extend groups = data.groups | mv-expand groups | extend rules = groups.rules | mv-expand rules

---
parse-json | extend "groups" = data.groups | mv-expand "groups" | extend "rules" = groups.rules | mv-expand "rules" | extend alertState = rules.alerts[].state, alertName = rules.alerts[].labels.alertname | project alertState, alertName
--
parse-json | extend "groups" = data.groups | mv-expand "groups" | extend "rules" = groups.rules | mv-expand "rules" | extend "alerts" = rules.alerts | mv-expand "alerts"

-------
parse-json | where "status" == "success" | project "data.groups[].name", "data.groups[].rules[].name", "data.groups[].rules[].state", "data.groups[].rules[].query", "data.groups[].rules[].duration", "data.groups[].rules[].labels.severity", "data.groups[].rules[].annotations.summary", "data.groups[].rules[].alerts[].state", "data.groups[].rules[].alerts[].annotations.summary", "data.groups[].rules[].alerts[].labels.instance"

=============
#!/bin/bash

# Wy≈õwietlenie ≈õcie≈ºek w JSON
json_paths=$(jq -r 'paths | map(tostring) | join(".")' plik.json)

# Iteracja przez ka≈ºdƒÖ ≈õcie≈ºkƒô i konwersja do formatu UQL
echo "${json_paths}" | while read -r path; do
  # Zmieniamy kropki na strza≈Çki
  uql_path=$(echo "$path" | sed 's/\./->/g')
  
  # Dla tablic UQL u≈ºywa innej notacji
  uql_path=$(echo "$uql_path" | sed 's/

\[\([0-9]*\)\]

/->["\1"]/g')
  
  # Wy≈õwietlenie w stylu UQL
  echo "$uql_path"
done

---------------------
#!/bin/bash

# ≈öcie≈ºka do pliku YAML wej≈õciowego
input_file="path/to/your/input_file.yaml"

# ≈öcie≈ºka do pliku wynikowego
output_file="path/to/your/output_file.txt"

# Wczytywanie, przefiltrowanie warto≈õci job_name, usuwanie cudzys≈Çow√≥w, spacji, my≈õlnik√≥w oraz pomijanie zakomentowanych linii
job_names=$(grep -v '^[[:space:]]*#' "$input_file" | grep 'job_name' | sed "s/.*job_name:[ ]*//g" | tr -d "'\"" | tr '\n' '|')

# Usuniƒôcie ostatniego znaku '|'
job_names=${job_names%|}

# Zapisanie wynik√≥w do pliku wynikowego
echo "$job_names" > "$output_file"

# Wy≈õwietlenie wynik√≥w na ekranie
cat "$output_file"



-----------------------
#!/bin/bash

# ≈öcie≈ºka do pliku YAML
yaml_file="path/to/your/file.yaml"

# Wczytywanie i przefiltrowanie job_names bez cudzys≈Çow√≥w, spacji oraz znak√≥w '-', z separatorami '|'
job_names=$(grep 'job_name' "$yaml_file" | sed "s/job_name:[ ]*//g" | tr -d "'\", -'" | tr '\n' '|')

# Dodatkowe przefiltrowanie, aby usunƒÖƒá znaki '-'
job_names=$(echo "$job_names" | tr -d '-')

# Usuniƒôcie ostatniego znaku '|'
job_names=${job_names%|}

# Wypisanie wynik√≥w
echo "$job_names"



---
#!/bin/bash

# ≈öcie≈ºka do pliku YAML
yaml_file="path/to/your/file.yaml"

# Wczytywanie i przefiltrowanie job_names bez cudzys≈Çow√≥w, spacji oraz znak√≥w '-', z separatorami '|'
job_names=$(grep 'job_name' "$yaml_file" | sed "s/job_name:[ ]*//g" | tr -d "'\", -'" | tr '\n' '|')

# Usuniƒôcie ostatniego znaku '|'
job_names=${job_names%|}

# Wypisanie wynik√≥w
echo "$job_names"



-----------
PUT _ingest/pipeline/copy_meta_project
{
  "description": "Kopiowanie warto≈õci meta.project z pola message do pola meta.project",
  "processors": [
    {
      "grok": {
        "field": "message",
        "patterns": ["\"meta\\.project\":\"(?<meta_project>[^\"]+)\""]
      }
    },
    {
      "set": {
        "if": "ctx.meta_project != null",
        "field": "meta.project",
        "value": "{{meta_project}}"
      }
    }
  ]
}

-------------
PUT _ingest/pipeline/copy_meta_project
{
  "description": "Kopiowanie warto≈õci meta.project z pola message do pola meta.project",
  "processors": [
    {
      "grok": {
        "field": "message",
        "patterns": ["\"meta\\.project\":\"(?<meta_project>[^\"]+)\""]
      }
    },
    {
      "set": {
        "field": "meta.project",
        "value": "{{meta_project}}"
      }
    }
  ]
}


------
PUT _ingest/pipeline/copy_meta_project
{
  "description": "Kopiowanie warto≈õci meta.project z pola message do pola meta.project",
  "processors": [
    {
      "grok": {
        "field": "message",
        "patterns": ["%{QUOTEDSTRING:meta_project_key}:%{QUOTEDSTRING:meta_project_value}"],
        "pattern_definitions": {
          "QUOTEDSTRING": "\"(?:[^\"\\\\]|\\\\.)*\""
        }
      }
    },
    {
      "set": {
        "field": "meta.project",
        "value": "{{meta_project_value}}"
      }
    }
  ]
}

---
- name: Ustawienie kluczy SSH na zdalnych hostach
  hosts: all
  tasks:
    - name: Generowanie klucza SSH, je≈õli nie istnieje
      command: ssh-keygen -t rsa -b 2048 -f ~/.ssh/id_rsa -q -N ""
      args:
        creates: ~/.ssh/id_rsa

    - name: Pobieranie zawarto≈õci klucza publicznego
      register: ssh_pub_key
      command: cat ~/.ssh/id_rsa.pub

    - name: Kopiowanie klucza publicznego na zdalne hosty
      authorized_key:
        user: "{{ ansible_user }}"
        key: "{{ ssh_pub_key.stdout }}"
        state: present



----------------------
#!/bin/bash

# Elasticsearch endpoint
ES_ENDPOINT="http://localhost:9200"
# Uwierzytelnianie
USERNAME="twoja_nazwa_u≈ºytkownika"
PASSWORD="twoje_has≈Ço"

# Sprawdzenie alias√≥w rollover
check_rollover_alias() {
  echo "Sprawdzanie alias√≥w rollover..."
  indices=$(curl -s -u $USERNAME:$PASSWORD -X GET "$ES_ENDPOINT/_cat/indices?h=index")
  for index in $indices; do
    alias=$(curl -s -u $USERNAME:$PASSWORD -X GET "$ES_ENDPOINT/_alias/$index" | jq -r '.[].aliases | keys[]')
    if [[ $alias == *"rollover"* ]]; then
      echo "Indeks $index ma alias rollover: $alias"
    else
      echo "Indeks $index nie ma aliasu rollover."
    fi
  done
}

# Sprawdzenie problem√≥w z rolloverem
check_rollover_issues() {
  echo "Sprawdzanie problem√≥w z rolloverem..."
  indices=$(curl -s -u $USERNAME:$PASSWORD -X GET "$ES_ENDPOINT/_cat/indices?h=index")
  for index in $indices; do
    rollover_info=$(curl -s -u $USERNAME:$PASSWORD -X GET "$ES_ENDPOINT/$index/_rollover")
    if [[ $rollover_info == *"error"* ]]; then
      echo "Indeks $index ma problem z rolloverem: $rollover_info"
    else
      echo "Indeks $index nie ma problem√≥w z rolloverem."
    fi
  done
}

# Wykonanie funkcji
check_rollover_alias
check_rollover_issues


--------------------------------------------
#!/bin/bash

# Pobierz tylko szablony indeks√≥w, kt√≥rych nazwa zaczyna siƒô od devwie01 lub devwie02
curl -X GET "http://localhost:9200/_index_template" -H 'Content-Type: application/json' -o templates.json

# Sprawd≈∫, czy plik templates.json istnieje i nie jest pusty
if [[ ! -s templates.json ]]; then
  echo "B≈ÇƒÖd: Plik templates.json jest pusty lub nie istnieje."
  exit 1
fi

# Sprawd≈∫ poprawno≈õƒá pliku JSON
jq . templates.json > /dev/null
if [[ $? -ne 0 ]]; then
  echo "B≈ÇƒÖd: Plik templates.json jest niepoprawny."
  exit 1
fi

# Utw√≥rz katalog z aktualnƒÖ datƒÖ, godzinƒÖ i minutƒÖ
backup_dir="/tmp/indexTemplateBackup/$(date +'%Y%m%d_%H%M')"
mkdir -p "$backup_dir"

# Iteruj przez ka≈ºdy szablon i zapisz do osobnego pliku tylko te, kt√≥re zaczynajƒÖ siƒô od devwie01 lub devwie02
jq -c '.index_templates[] | select(.name | startswith("devwie01") or startswith("devwie02"))' templates.json | while IFS= read -r template; do
  name=$(echo "$template" | jq -r '.name')
  body=$(echo "$template" | jq -c '.index_template | del(.version, .composed_of)')
  echo "$body" > "${backup_dir}/${name}.json"
done

echo "Szablony indeks√≥w zosta≈Çy zapisane w katalogu: $backup_dir"

---------
#!/bin/bash

# Pobierz wszystkie szablony indeks√≥w
curl -X GET "http://localhost:9200/_index_template" -H 'Content-Type: application/json' -o templates.json

# Utw√≥rz katalog z aktualnƒÖ datƒÖ, godzinƒÖ i minutƒÖ
backup_dir="/tmp/indexTemplateBackup/$(date +'%Y%m%d_%H%M')"
mkdir -p "$backup_dir"

# Iteruj przez ka≈ºdy szablon i zapisz do osobnego pliku tylko te, kt√≥re zaczynajƒÖ siƒô od devwie01 lub devwie02
for template in $(jq -c '.index_templates[]' templates.json); do
  name=$(echo $template | jq -r '.name')
  if [[ $name == devwie01* || $name == devwie02* ]]; then
    body=$(echo $template | jq -c '.index_template | del(.version, .composed_of)')
    echo $body > "${backup_dir}/${name}.json"
  fi
done

echo "Szablony indeks√≥w zosta≈Çy zapisane w katalogu: $backup_dir"

----
#!/bin/bash

# Pobierz wszystkie szablony indeks√≥w
curl -X GET "http://localhost:9200/_index_template" -H 'Content-Type: application/json' -o templates.json

# Utw√≥rz katalog z aktualnƒÖ datƒÖ, godzinƒÖ i minutƒÖ
backup_dir="/tmp/indexTemplateBackup/$(date +'%Y%m%d_%H%M')"
mkdir -p "$backup_dir"

# Iteruj przez ka≈ºdy szablon i zapisz do osobnego pliku
for template in $(jq -c '.index_templates[]' templates.json); do
  name=$(echo $template | jq -r '.name')
  body=$(echo $template | jq -c '.index_template | del(.version, .composed_of)')
  echo $body > "${backup_dir}/${name}.json"
done

echo "Szablony indeks√≥w zosta≈Çy zapisane w katalogu: $backup_dir"

------------
# Pobierz wszystkie szablony indeks√≥w
curl -X GET "http://localhost:9200/_index_template" -H 'Content-Type: application/json' -o templates.json

# Iteruj przez ka≈ºdy szablon i zapisz do osobnego pliku
for template in $(jq -c '.index_templates[]' templates.json); do
  name=$(echo $template | jq -r '.name')
  body=$(echo $template | jq -c '.index_template | del(.version, .composed_of)')
  echo $body > "${name}.json"
done

-----------
for file in *.json; do
  name=$(basename "$file" .json)
  curl -X PUT "http://localhost:9200/_index_template/$name" -H 'Content-Type: application/json' -d @"$file"
done

-----------------------------
# Pobierz wszystkie szablony indeks√≥w
curl -X GET "http://localhost:9200/_index_template" -H 'Content-Type: application/json' -o templates.json

# Iteruj przez ka≈ºdy szablon i zapisz do osobnego pliku
for template in $(jq -c '.index_templates[]' templates.json); do
  name=$(echo $template | jq -r '.name')
  body=$(echo $template | jq -c '.index_template | del(.version, .composed_of)')
  echo $body > "${name}.json"
done



---------------
for template in $(jq -c '.index_templates[]' templates.json); do
  name=$(echo $template | jq -r '.name')
  body=$(echo $template | jq -c '.index_template')
  curl -X PUT "http://localhost:9200/_index_template/$name" -H 'Content-Type: application/json' -d "$body"
done

-------------
jq 'recurse(.[]? | select(type == "object")) | select(depth >= 2)' input.json



sed 's/^.*{"index_patterns":\[/{\"index_patterns\":\[/' plik.txt

........
#!/bin/bash

# Plik do edycji
file="plik.txt"

# Tekst do usuniƒôcia z poczƒÖtku linii
start_remove='{"index_templates":['

# Tekst do usuniƒôcia z ko≈Ñca linii
end_remove=']}'

# Usu≈Ñ tekst z poczƒÖtku linii
sed -i "s/^$start_remove//" "$file"

# Usu≈Ñ tekst z ko≈Ñca linii
sed -i "s/$end_remove\$//" "$file"



#!/bin/bash

# Plik do edycji
file="plik.txt"

# Tekst do usuniƒôcia z poczƒÖtku pierwszej linii
start_remove='{"index_templates":['

# Tekst do usuniƒôcia z ko≈Ñca ostatniej linii
end_remove=']}'

# Usu≈Ñ tekst z poczƒÖtku pierwszej linii
sed -i "1s/^$start_remove//" "$file"

# Usu≈Ñ tekst z ko≈Ñca ostatniej linii
sed -i "\$s/$end_remove\$//" "$file"

-------------
curl -X GET "http://localhost:9200/_index_template" -H 'Content-Type: application/json' | jq '.index_templates[] | select(.index_template.template.settings.index.default_pipeline != null)'

---------------------------------------

#!/bin/bash

# Zmienna przechowujƒÖca nazwƒô u≈ºytkownika i adres serwera
USER="twoj_uzytkownik"
HOST="adres_serwera"

# ≈öcie≈ºka do pliku z kluczem publicznym
KEY="$HOME/.ssh/id_rsa.pub"

# Sprawdzenie, czy klucz jest ju≈º na serwerze
ssh -q $USER@$HOST "grep -q -f $KEY ~/.ssh/authorized_keys"

# Je≈õli klucz nie jest znaleziony, wykonaj ssh-copy-id
if [ $? -ne 0 ]; then
    ssh-copy-id $USER@$HOST
else
    echo "Klucz SSH jest ju≈º skopiowany na serwer."
fi

------------------------------
#!/bin/bash

# Utworzenie dwuwymiarowej tablicy
declare -A dwuwymiarowa_tablica

# Ustawienie warto≈õci dla pierwszego klucza (zmieniajƒÖcego siƒô)
dwuwymiarowa_tablica["klucz1","wielko≈õƒá"]="123"
dwuwymiarowa_tablica["klucz1","inne"]="456"

# Ustawienie warto≈õci dla drugiego klucza (sta≈Çe)
dwuwymiarowa_tablica["klucz2","wielko≈õƒá"]="789"
dwuwymiarowa_tablica["klucz2","inne"]="abc"

# Wypisanie warto≈õci z osobnej pƒôtli
for klucz in "${!dwuwymiarowa_tablica[@]}"; do
    echo "Warto≈õƒá dla klucza $klucz: ${dwuwymiarowa_tablica[$klucz]}"
done




#!/bin/bash

# Ustawienie warto≈õci dla zmiennej tablicowej suma_polityki
polityka="test-ilm"
fabryka_wielkosc="123"
suma_polityki["$polityka"]["wielko≈õƒá"]=$fabryka_wielkosc



# Wypisanie warto≈õci zmiennej tablicowej suma_polityki
echo "Warto≈õƒá suma_polityki[$polityka][wielko≈õƒá]: ${suma_polityki[$polityka][wielko≈õƒá]}"




#!/bin/bash

# Ustawienie warto≈õci dla zmiennej tablicowej suma_polityki
polityka="test-ilm"
fabryka_wielkosc="123"
suma_polityki["$polityka"]["wielko≈õƒá"]=$fabryka_wielkosc

# Wypisanie warto≈õci zmiennej tablicowej suma_polityki
echo "Warto≈õƒá suma_polityki[$polityka][wielko≈õƒá]: ${suma_polityki[$polityka][wielko≈õƒá]}"




#!/bin/bash

# Przypisanie warto≈õci dla zmiennych
polityka="test-ilm"
fabryka_wielkosc="123"

# Utworzenie tablicy suma_polityki i przypisanie warto≈õci
declare -A suma_polityki
suma_polityki["$polityka"]=""
suma_polityki["$polityka"]["wielko≈õƒá"]="$fabryka_wielkosc"

# Wy≈õwietlenie warto≈õci dla klucza $polityka i klucza wielko≈õƒá
echo "${suma_polityki[$polityka][wielko≈õƒá]}"



#!/bin/bash

# Ustawienie warto≈õci dla zmiennej tablicowej
polityka="test-ilm"
fabryka_wielkosc="123"
suma_polityki["$polityka"]["wielko≈õƒá"]=$fabryka_wielkosc

# Wypisanie warto≈õci zmiennej
echo "Warto≈õƒá zmiennej suma_polityki: ${suma_polityki[$polityka][wielko≈õƒá]}"



# Wy≈õwietlenie wynik√≥w jako JSON i zapis do pliku
for polityka in "${!wyniki_json[@]}"; do
    echo "\"$polityka\": ${wyniki_json["$polityka"]}"
done | jq -s . > wyniki.json
------------------
suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")

    suma_bajty_z_replika=${suma_polityk_z_replika["$polityka"]}
    suma_MB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024")
    suma_GB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024")
    suma_TB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024 / 1024")

    wyniki_json["$polityka"]='{"bez_repliki":{"Bajty":'$suma_bajty',"MB":'$suma_MB',"GB":'$suma_GB',"TB":'$suma_TB'},"z_replika":{"Bajty":'$suma_bajty_z_replika',"MB":'$suma_MB_z_replika',"GB":'$suma_GB_z_replika',"TB":'$suma_TB_z_replika'}}'

--------------------
#!/bin/bash
# Tworzymy asocjacyjny s≈Çownik, w kt√≥rym kluczem jest nazwa polityki, a warto≈õciƒÖ suma wielko≈õci w bajtach
declare -A suma_polityk
# Przetwarzamy dane linia po linii
while read -r line; do
    # Sprawdzamy, czy linia nie jest pusta
    if [[ -n "$line" ]]; then
        index=$(echo "$line" | jq -r '.indexname')
        polityka=$(echo "$line" | jq -r '.ilmname')
        wielkosc_index=$(echo "$line" | jq -r '.sizeindex')
        wielkosc_index_z_replika=$(echo "$line" | jq -r '.sizeindexwithreplica')

        # Dodajemy wielko≈õci do sumy dla danej polityki
        suma_polityk["$polityka"]=$((suma_polityk["$polityka"] + wielkosc_index))
        suma_polityk_z_replika["$polityka"]=$((suma_polityk_z_replika["$polityka"] + wielkosc_index_z_replika))
    fi
done < plik_z_danymi.txt
for polityka in "${!suma_polityk[@]}"; do
    suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")
    echo "Suma wielko≈õci dla polityki $polityka (bez repliki):"
    echo "  Bajty: $suma_bajty"
    echo "  MB: $suma_MB"
    echo "  GB: $suma_GB"
    echo "  TB: $suma_TB"
    suma_bajty_z_replika=${suma_polityk_z_replika["$polityka"]}
    suma_MB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024")
    suma_GB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024")
    suma_TB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024 / 1024")
    echo "Suma wielko≈õci dla polityki $polityka (z replikƒÖ):"
    echo "  Bajty: $suma_bajty_z_replika"
    echo "  MB: $suma_MB_z_replika"
    echo "  GB: $suma_GB_z_replika"
    echo "  TB: $suma_TB_z_replika"
done


----------------------------------------------------------
#!/bin/bash
# Tworzymy asocjacyjny s≈Çownik, w kt√≥rym kluczem jest nazwa polityki, a warto≈õciƒÖ suma wielko≈õci w bajtach
declare -A suma_polityk
declare -A suma_polityk_z_replika

# Przetwarzamy dane linia po linii
while read -r line; do
    # Sprawdzamy, czy linia nie jest pusta
    if [[ -n "$line" ]]; then
        # WyciƒÖgamy warto≈õci index, polityka, wielko≈õƒá index oraz wielko≈õƒá index z replikƒÖ
        index=$(echo "$line" | jq -r '.indexname')
        polityka=$(echo "$line" | jq -r '.ilmname')
        wielkosc_index=$(echo "$line" | jq -r '.sizeindex')
        wielkosc_index_z_replika=$(echo "$line" | jq -r '.sizeindexwithreplica')

        # Dodajemy wielko≈õci do sumy dla danej polityki
        suma_polityk["$polityka"]=$(bc <<< "${suma_polityk["$polityka"]} + $wielkosc_index")
        suma_polityk_z_replika["$polityka"]=$(bc <<< "${suma_polityk_z_replika["$polityka"]} + $wielkosc_index_z_replika")
    fi
done < plik_z_danymi.txt

# Wy≈õwietlamy wyniki w r√≥≈ºnych jednostkach
for polityka in "${!suma_polityk[@]}"; do
    suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielko≈õci dla polityki $polityka (bez repliki):"
    echo "  Bajty: $suma_bajty"
    echo "  MB: $suma_MB"
    echo "  GB: $suma_GB"
    echo "  TB: $suma_TB"

    suma_bajty_z_replika=${suma_polityk_z_replika["$polityka"]}
    suma_MB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024")
    suma_GB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024")
    suma_TB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielko≈õci dla polityki $polityka (z replikƒÖ):"
    echo "  Bajty: $suma_bajty_z_replika"
    echo "  MB: $suma_MB_z_replika"
    echo "  GB: $suma_GB_z_replika"
    echo "  TB: $suma_TB_z_replika"
done



-------------------------------------------
#!/bin/bash
# Tworzymy asocjacyjny s≈Çownik, w kt√≥rym kluczem jest nazwa polityki, a warto≈õciƒÖ suma wielko≈õci w bajtach
declare -A suma_polityk
declare -A suma_polityk_z_replika

# Przetwarzamy dane linia po linii
while read -r line; do
    # Sprawdzamy, czy linia nie jest pusta
    if [[ -n "$line" ]]; then
        # WyciƒÖgamy warto≈õci index, polityka, wielko≈õƒá index oraz wielko≈õƒá index z replikƒÖ
        index=$(echo "$line" | jq -r '.indexname')
        polityka=$(echo "$line" | jq -r '.ilmname')
        wielkosc_index=$(echo "$line" | jq -r '.sizeindex')
        wielkosc_index_z_replika=$(echo "$line" | jq -r '.sizeindexwithreplica')

        # Dodajemy wielko≈õci do sumy dla danej polityki
        suma_polityk["$polityka"]=$(bc <<< "${suma_polityk["$polityka"]} + $wielkosc_index")
        suma_polityk_z_replika["$polityka"]=$(bc <<< "${suma_polityk_z_replika["$polityka"]} + $wielkosc_index_z_replika")
    fi
done < plik_z_danymi.txt

# Wy≈õwietlamy wyniki w r√≥≈ºnych jednostkach
for polityka in "${!suma_polityk[@]}"; do
    suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielko≈õci dla polityki $polityka (bez repliki):"
    echo "  Bajty: $suma_bajty"
    echo "  MB: $suma_MB"
    echo "  GB: $suma_GB"
    echo "  TB: $suma_TB"

    suma_bajty_z_replika=${suma_polityk_z_replika["$polityka"]}
    suma_MB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024")
    suma_GB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024")
    suma_TB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielko≈õci dla polityki $polityka (z replikƒÖ):"
    echo "  Bajty: $suma_bajty_z_replika"
    echo "  MB: $suma_MB_z_replika"
    echo "  GB: $suma_GB_z_replika"
    echo "  TB: $suma_TB_z_replika"
done

------------------------------------------------------------------------------------
#!/bin/bash
# Tworzymy asocjacyjny s≈Çownik, w kt√≥rym kluczem jest nazwa polityki, a warto≈õciƒÖ suma wielko≈õci w bajtach
declare -A suma_polityk

# Przetwarzamy dane linia po linii
while read -r line; do
    # Sprawdzamy, czy linia nie jest pusta
    if [[ -n "$line" ]]; then
        # WyciƒÖgamy warto≈õci index, polityka, wielko≈õƒá index oraz wielko≈õƒá index z replikƒÖ
        index=$(echo "$line" | jq -r '.indexname')
        polityka=$(echo "$line" | jq -r '.ilmname')
        wielkosc_index=$(echo "$line" | jq -r '.sizeindex')
        wielkosc_index_z_replika=$(echo "$line" | jq -r '.sizeindexwithreplica')

        # Dodajemy wielko≈õci do sumy dla danej polityki
        suma_polityk["$polityka"]=$((suma_polityk["$polityka"] + wielkosc_index))
        suma_polityk_z_replika["$polityka"]=$((suma_polityk_z_replika["$polityka"] + wielkosc_index_z_replika))
    fi
done < plik_z_danymi.txt

# Wy≈õwietlamy wyniki w r√≥≈ºnych jednostkach
for polityka in "${!suma_polityk[@]}"; do
    suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielko≈õci dla polityki $polityka (bez repliki):"
    echo "  Bajty: $suma_bajty"
    echo "  MB: $suma_MB"
    echo "  GB: $suma_GB"
    echo "  TB: $suma_TB"

    suma_bajty_z_replika=${suma_polityk_z_replika["$polityka"]}
    suma_MB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024")
    suma_GB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024")
    suma_TB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielko≈õci dla polityki $polityka (z replikƒÖ):"
    echo "  Bajty: $suma_bajty_z_replika"
    echo "  MB: $suma_MB_z_replika"
    echo "  GB: $suma_GB_z_replika"
    echo "  TB: $suma_TB_z_replika"
done

-------------------------------------------------------------------------------------
#!/bin/bash

# Tworzymy asocjacyjny s≈Çownik, w kt√≥rym kluczem jest nazwa polityki, a warto≈õciƒÖ suma wielko≈õci w bajtach
declare -A suma_polityk

# Przetwarzamy dane linia po linii
while read -r line; do
    # Sprawdzamy, czy linia nie jest pusta
    if [[ -n "$line" ]]; then
        # WyciƒÖgamy warto≈õci index, polityka, wielko≈õƒá index oraz wielko≈õƒá index z replikƒÖ
        index=$(echo "$line" | jq -r '.indexname')
        polityka=$(echo "$line" | jq -r '.ilmname')
        wielkosc_index=$(echo "$line" | jq -r '.sizeindex')
        wielkosc_index_z_replika=$(echo "$line" | jq -r '.sizeindexwithreplica')

        # Dodajemy wielko≈õci do sumy dla danej polityki
        suma_polityk["$polityka"]=$((suma_polityk["$polityka"] + wielkosc_index + wielkosc_index_z_replika))
    fi
done < plik_z_danymi.txt

# Wy≈õwietlamy wyniki w r√≥≈ºnych jednostkach
for polityka in "${!suma_polityk[@]}"; do
    suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielko≈õci dla polityki $polityka:"
    echo "  Bajty: $suma_bajty"
    echo "  MB: $suma_MB"
    echo "  GB: $suma_GB"
    echo "  TB: $suma_TB"
done

# Obliczamy sumƒô wszystkich polityk w r√≥≈ºnych jednostkach
suma_wszystkich_bajty=$(echo "${suma_polityk[@]}" | tr ' ' '+' | bc)
suma_wszystkich_MB=$(bc <<< "scale=2; $suma_wszystkich_bajty / 1024 / 1024")
suma_wszystkich_GB=$(bc <<< "scale=2; $suma_wszystkich_bajty / 1024 / 1024 / 1024")
suma_wszystkich_TB=$(bc <<< "scale=2; $suma_wszystkich_bajty / 1024 / 1024 / 1024 / 1024")

echo "Suma wielko≈õci dla wszystkich polityk:"
echo "  Bajty: $suma_wszystkich_bajty"
echo "  MB: $suma_wszystkich_MB"
echo "  GB: $suma_wszystkich_GB"
echo "  TB: $suma_wszystkich_TB"




======================================================================================================
<VirtualHost *:80>
    ServerName your-server-name
    DocumentRoot /var/www/html

    # W≈ÇƒÖcz modu≈Ç statusu
    <Location /server-status>
        SetHandler server-status
        Order Deny,Allow
        Deny from all
        Allow from localhost ip6-localhost
        # U≈ºyj SSLRequire do wymuszenia autoryzacji certyfikatem
        SSLRequireSSL
        SSLVerifyClient require
        SSLVerifyDepth  10
    </Location>

    # W≈ÇƒÖcz eksport metryk w formacie prometheushowym
    <Location /metrics>
        SetHandler prometheus-metrics
        Order Deny,Allow
        Deny from all
        Allow from localhost ip6-localhost
        # U≈ºyj SSLRequire do wymuszenia autoryzacji certyfikatem
        SSLRequireSSL
        SSLVerifyClient require
        SSLVerifyDepth  10
    </Location>

    # Konfiguracja SSL
    SSLEngine on
    SSLCertificateFile "/path/to/your/certificate.pem"
    SSLCertificateKeyFile "/path/to/your/private/key.pem"
    SSLCACertificateFile "/path/to/your/ca_certificate.pem"
</VirtualHost>




Oto przyk≈Çadowa konfiguracja Apache, kt√≥ra spe≈Çnia Twoje wymagania:

```apache
<VirtualHost *:80>
    ServerName your-server-name
    DocumentRoot /var/www/html

    # W≈ÇƒÖcz modu≈Ç statusu
    <Location /server-status>
        SetHandler server-status
        Order Deny,Allow
        Deny from all
        Allow from localhost ip6-localhost
        # U≈ºyj SSLRequire do wymuszenia autoryzacji certyfikatem
        SSLRequireSSL
        SSLVerifyClient require
        SSLVerifyDepth  10
    </Location>

    # W≈ÇƒÖcz eksport metryk w formacie prometheushowym
    <Location /metrics>
        SetHandler prometheus-metrics
        Order Deny,Allow
        Deny from all
        Allow from localhost ip6-localhost
        # U≈ºyj SSLRequire do wymuszenia autoryzacji certyfikatem
        SSLRequireSSL
        SSLVerifyClient require
        SSLVerifyDepth  10
    </Location>

    # Konfiguracja SSL
    SSLEngine on
    SSLCertificateFile "/path/to/your/certificate.pem"
    SSLCertificateKeyFile "/path/to/your/private/key.pem"
    SSLCACertificateFile "/path/to/your/ca_certificate.pem"
</VirtualHost>
```

Pamiƒôtaj, ≈ºe powy≈ºsza konfiguracja jest tylko przyk≈Çadem i mo≈ºe wymagaƒá dostosowania do Twojego konkretnego ≈õrodowiska 
i wymaga≈Ñ. Upewnij siƒô, ≈ºe ≈õcie≈ºki do plik√≥w certyfikat√≥w sƒÖ poprawne i ≈ºe masz odpowiednie uprawnienia do ich odczytu.
Ponadto, upewnij siƒô, ≈ºe masz zainstalowany i w≈ÇƒÖczony modu≈Ç `mod_status` dla Apache, kt√≥ry jest wymagany do udostƒôpniania
metryk serwera. Dla metryk w formacie prometheushowym, bƒôdziesz potrzebowaƒá dodatkowego modu≈Çu jak `mod_prometheus`. 

Zawsze zaleca siƒô testowanie wszelkich zmian konfiguracji w ≈õrodowisku testowym przed ich wdro≈ºeniem na produkcjƒô.



-----------------------

#!/bin/bash

# Deklaracja tablicy asocjacyjnej
declare -A moja_tablica

# Dodawanie warto≈õci do tablicy
moja_tablica["klucz1"]="wartosc1"
moja_tablica["klucze12"]="wartosci12"
moja_tablica["toKlucz"]="ToWartosc"
moja_tablica["tata"]="rata"

# Wy≈õwietlanie warto≈õci dla danego klucza
for klucz in "${!moja_tablica[@]}"; do
    wartosc="${moja_tablica[$klucz]}"
    echo "Klucz: $klucz, Warto≈õƒá: $wartosc"
done
##############################################################################################3
Oto zmodyfikowane przyk≈Çady dla NGINX i job√≥w Prometheus, kt√≥re uwzglƒôdniajƒÖ podane przez Ciebie dane:

**Konfiguracja NGINX:**

```bash
http {
    upstream backend {
        server 192.168.100.101;
        server 192.168.100.102;
    }

    server {
        listen 9091;
        server_name app1;

        location / {
            proxy_pass http://192.168.100.201/metric;
            auth_basic "Restricted Content";
            auth_basic_user_file /etc/nginx/.htpasswd_app1;
        }
    }

    server {
        listen 9092;
        server_name app2;

        location / {
            proxy_pass http://192.168.100.202/metric;
            auth_basic "Restricted Content";
            auth_basic_user_file /etc/nginx/.htpasswd_app2;
        }
    }
}
```

**Konfiguracja job√≥w Prometheus:**

```yaml
scrape_configs:
  - job_name: 'app1'
    scrape_interval: 5s
    static_configs:
      - targets: ['192.168.100.201:9091']
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
        replacement: app1
    basic_auth:
      username: 'user1'
      password: 'password1'

  - job_name: 'app2'
    scrape_interval: 5s
    static_configs:
      - targets: ['192.168.100.202:9092']
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
        replacement: app2
    basic_auth:
      username: 'user2'
      password: 'password2'
```

W powy≈ºszych przyk≈Çadach, `192.168.100.201:9091` i `192.168.100.202:9092` to adresy, z kt√≥rych Prometheus bƒôdzie zbiera≈Ç metryki. SƒÖ one mapowane na `app1` i `app2` odpowiednio za pomocƒÖ `relabel_configs`. Autentykacja jest obs≈Çugiwana przez `basic_auth`, gdzie `username` i `password` to dane uwierzytelniajƒÖce dla ka≈ºdego joba.

Pamiƒôtaj, ≈ºe powy≈ºsza konfiguracja jest tylko przyk≈Çadem i mo≈ºe wymagaƒá dostosowania do twojego konkretnego ≈õrodowiska i wymaga≈Ñ.
-----------------------------
scrape_configs:
  - job_name: 'app1'
    scrape_interval: 5s
    static_configs:
      - targets: ['localhost:9091']
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
        replacement: app1
    basic_auth:
      username: 'user1'
      password: 'password1'

  - job_name: 'app2'
    scrape_interval: 5s
    static_configs:
      - targets: ['localhost:9092']
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
        replacement: app2
    basic_auth:
      username: 'user2'
      password: 'password2'




Aby skonfigurowaƒá osobne organizacje dla `app1` i `app2` w Grafana, musisz najpierw utworzyƒá organizacje, a nastƒôpnie dodaƒá do nich odpowiednie ≈∫r√≥d≈Ça danych. Poni≈ºej znajduje siƒô przyk≈Çadowy proces:

1. **Utw√≥rz organizacje**: Zaloguj siƒô do Grafana jako administrator i przejd≈∫ do `Configuration > Server Admin > Organizations`. Kliknij `New Organization` i wprowad≈∫ nazwƒô organizacji (np. `app1` i `app2`).

2. **Dodaj ≈∫r√≥d≈Ça danych**: Przejd≈∫ do `Configuration > Data Sources` i kliknij `Add data source`. Wybierz `Prometheus` jako typ ≈∫r√≥d≈Ça danych i wprowad≈∫ odpowiednie szczeg√≥≈Çy, takie jak adres URL serwera Prometheus.

Poni≈ºej znajduje siƒô przyk≈Çadowa konfiguracja ≈∫r√≥d≈Ça danych dla `app1`:

```yaml
name: Prometheus-app1
type: prometheus
access: proxy
url: http://192.168.100.101:9091
basicAuth: true
basicAuthUser: user1
basicAuthPassword: password1
```

Podobnie, dla `app2`:

```yaml
name: Prometheus-app2
type: prometheus
access: proxy
url: http://192.168.100.102:9092
basicAuth: true
basicAuthUser: user2
basicAuthPassword: password2
```

Pamiƒôtaj, ≈ºe powy≈ºsza konfiguracja jest tylko przyk≈Çadem i mo≈ºe wymagaƒá dostosowania do twojego konkretnego ≈õrodowiska i wymaga≈Ñ. Zawsze nale≈ºy przestrzegaƒá najlepszych praktyk bezpiecze≈Ñstwa podczas konfigurowania autentykacji i upewniƒá siƒô, ≈ºe wszystkie has≈Ça i dane uwierzytelniajƒÖce sƒÖ odpowiednio zabezpieczone.





--------------------------------------
http {
    server {
        listen 9091;
        server_name app1;

        location / {
            proxy_pass http://localhost:9091;
            auth_basic "Restricted Content";
            auth_basic_user_file /etc/nginx/.htpasswd_app1;
        }
    }

    server {
        listen 9092;
        server_name app2;

        location / {
            proxy_pass http://localhost:9092;
            auth_basic "Restricted Content";
            auth_basic_user_file /etc/nginx/.htpasswd_app2;
        }
    }
}

-------------------------------------------------------
https://www.elastic.co/guide/en/elasticsearch/reference/8.8/logging.html
-------------------------------------------------------
/var/log/elasticsearch/crlo-*audit*json.gz {
    daily
    missingok
    nocompress
    notifempty
    create 640 root adm
    postrotate
        find /var/log/elasticsearch/ -name "crlo-*audit*json.gz" -mtime +3 -delete
    endscript
}


------------
curl -X GET "http://localhost:5601/api/saved_objects/_find?type=index-pattern&space_id=nazwa_space" -H 'kbn-xsrf: true'

-----------------------------
Aby dodaƒá nowy indeks do `indices names` dla danej roli w Elasticsearch, mo≈ºesz najpierw pobraƒá aktualnƒÖ listƒô indeks√≥w, a nastƒôpnie dodaƒá nowy indeks do tej listy i zaktualizowaƒá rolƒô za pomocƒÖ polecenia `curl`. Poni≈ºej znajduje siƒô przyk≈Çadowy skrypt bash, kt√≥ry wykonuje te zadania:

```bash
# Wykonaj polecenie curl i zapisz wynik do zmiennej
rola="twoja_rola"
wynik=$(curl -X GET "localhost:9200/_security/role/$rola")

# U≈ºyj jq, aby przetworzyƒá wynik i uzyskaƒá dostƒôp do indices names
indices_names=$(echo "$wynik" | jq -r ".[\"$rola\"].indices")

# Dodaj nowy indeks do listy
nowy_indeks="twoj_nowy_indeks"
zmienione_indices_names=$(echo "$indices_names" | jq ". += [\"$nowy_indeks\"]")

# Zaktualizuj rolƒô za pomocƒÖ zmienionej listy indeks√≥w
zmieniona_rola=$(echo "$wynik" | jq ".[\"$rola\"].indices = $zmienione_indices_names")
curl -X PUT "localhost:9200/_security/role/$rola" -H 'Content-Type: application/json' -d"$zmieniona_rola"
```

W tym skrypcie, `. += [\"$nowy_indeks\"]` to wyra≈ºenie `jq`, kt√≥re dodaje nowy indeks do listy indeks√≥w. Nastƒôpnie `.indices = $zmienione_indices_names` aktualizuje listƒô indeks√≥w dla danej roli.

Pamiƒôtaj, ≈ºe musisz zastƒÖpiƒá `"localhost:9200"`, `"twoja_rola"` i `"twoj_nowy_indeks"` odpowiednimi warto≈õciami. Je≈õli Tw√≥j klaster Elasticsearch jest zabezpieczony, musisz r√≥wnie≈º dostarczyƒá odpowiednie dane uwierzytelniajƒÖce z ≈ºƒÖdaniem `curl`.

Mam nadziejƒô, ≈ºe to pomo≈ºe! Je≈õli masz jakiekolwiek pytania lub potrzebujesz dalszej pomocy, daj mi znaƒá! üòä
--------------------------------------------------------------
# Wykonaj polecenie curl i zapisz wynik do zmiennej
wynik=$(curl -X GET "localhost:9200/_security/role" | jq -r 'keys | .[]')

# U≈ºyj pƒôtli while do odczytywania wynik√≥w linia po linii
echo "$wynik" | while read -r rola
do
   echo "$rola"
done

----------------------------------------------------
# Wykonaj polecenie curl i zapisz wynik do zmiennej
wynik=$(curl -X GET "localhost:9200/_security/role" | jq -r 'keys[]')

# U≈ºyj IFS (Internal Field Separator) do podzia≈Çu wyniku na tablicƒô
IFS=$'\n' read -r -a tablica <<< "$wynik"

# Wy≈õwietl ka≈ºdy element tablicy
for rola in "${tablica[@]}"
do
   echo "$rola"
done


------------------------------------
# Wykonaj polecenie curl i zapisz wynik do zmiennej
wynik=$(curl -s 'http://twojastrona.com')

# U≈ºyj IFS (Internal Field Separator) do podzia≈Çu wyniku na tablicƒô
IFS=' ' read -r -a tablica <<< "$wynik"

# Wy≈õwietl ka≈ºdy element tablicy
for element in "${tablica[@]}"
do
   echo "$element"
done

-------------

while read -r line; do
    indices=$(echo $line | grep -oP '(?<="indices":{").*?(?=")')
    storage_size=$(echo $line | grep -oP '(?<=storage.size: ).*?(?= )')
    pri_storage_size=$(echo $line | grep -oP '(?<=pri.storage.size: ).*')
    echo "Indices: $indices"
    echo "Storage size: $storage_size"
    echo "Primary storage size: $pri_storage_size"
done < input.txt
-----------------
script:
  - if [[ $fileList == *"plik1"* ]]; then
      ls -la;
    elif [[ $fileList == *"plik2"* ]]; then
      ls -ltr;
    fi

----------------------------------------
- name: Utw√≥rz katalog je≈õli nie istnieje
      file:
        path: /≈õcie≈ºka/do/katalogu
        state: directory
-------------------------------
- name: Zarchiwizuj istniejƒÖce pliki
      copy:
        src: "/lokalizacja/sprawdz/{{ item.item }}"
        dest: "/backup/{{ item.item }}.bak"
        remote_src: yes
      when: item.stat.exists
      loop: "{{ files_stat.results }}"

    - name: Skopiuj nowe pliki do katalogu /lokalizacja/sprawdz
      copy:
        src: "/example/folder/{{ item }}"
        dest: "/lokalizacja/sprawdz/{{ item }}"
      loop: "{{ files_list }}"
---------------------------------------
- FILES=$(echo '['$(ls -1 /example/folder | sed 's/^/"/;s/$/"/' | paste -sd, -)']')
--------------------
dc1_array = [["c7.cluster.pl", "c8.cluster.pl"]]
dc2_array = [["d7.cluster.pl"]]

def check_element(element):
    # Sp≈Çaszczanie list wewnƒôtrznych
    dc1_flat = [item for sublist in dc1_array for item in sublist]
    dc2_flat = [item for sublist in dc2_array for item in sublist]

    if element in dc1_flat:
        print(f"{element} znajduje siƒô w dc1_array")
    elif element in dc2_flat:
        print(f"{element} znajduje siƒô w dc2_array")
    else:
        print(f"{element} nie znajduje siƒô ani w dc1_array, ani w dc2_array")

# Przyk≈Çadowe u≈ºycie funkcji
check_element("c7.cluster.pl")
check_element("d7.cluster.pl")
check_element("c9.cluster.pl")

------------------------
CLUSTER_ARRAY = [["c7.cluster.pl", "c8.cluster.pl"], ["d7.cluster.pl"]]
dc1_array = [["c7.cluster.pl", "c8.cluster.pl"]]
dc2_array = [["d7.cluster.pl"]]

# Sp≈Çaszczanie list wewnƒôtrznych
dc1_flat = [item for sublist in dc1_array for item in sublist]
dc2_flat = [item for sublist in dc2_array for item in sublist]

# Iteracja po li≈õcie list
for cluster in CLUSTER_ARRAY:
    for server in cluster:
        if server in dc1_flat:
            print(f"{server} znajduje siƒô w dc1_array")
        elif server in dc2_flat:
            print(f"{server} znajduje siƒô w dc2_array")
        else:
            print(f"{server} nie znajduje siƒô ani w dc1_array, ani w dc2_array")

------------------------------------------------------------------------------
job1:
  variables:
    CLUSTER_LIST: '[["c7.cluster.pl", "c8.cluster.pl"], ["d7.cluster.pl"]]'
  script:
    - python3 my_script.py


import os
import json

cluster_list = json.loads(os.environ['CLUSTER_LIST'])

for cluster in cluster_list:
    for server in cluster:
        print(server)

--------------------------------------------------------------------
ifArray = [[["pole", "-eq", "warto≈õƒá", "and"],
            ["pole", "-eq", "warto≈õƒá", "and"],
            ["pole", "-eq", "warto≈õƒá"]],
           [["pole", "-eq", "warto≈õƒá", "and"],
            ["pole", "-eq", "warto≈õƒá"]],
           [["pole", "-eq", "warto≈õƒá"]]]

for i in range(len(ifArray)):
    for j in range(len(ifArray[i])):
        for k in range(len(ifArray[i][j])):
            print(f"ifArray[{i}][{j}][{k}] = {ifArray[i][j][k]}")
------------------------
declare -A my_array
my_array=(["key1:subkey1"]="value1" ["key1:subkey2"]="value2" ["key2:subkey1"]="value3")

# Iteracja po kluczach tablicy asocjacyjnej za pomocƒÖ pƒôtli for
for key in "${!my_array[@]}"
do
    # Podzia≈Ç klucza na czƒô≈õci
    IFS=':' read -ra key_parts <<< "$key"
    # Wypisanie klucza i warto≈õci
    echo "${key_parts[0]}, ${key_parts[1]}: ${my_array[$key]}"
done
-------
#!/bin/bash

declare -A ifArray

ifArray[0,0,0]="pole"
ifArray[0,0,1]="-eq"
ifArray[0,0,2]="warto≈õƒá"
ifArray[0,0,3]="and"

ifArray[0,1,0]="pole"
ifArray[0,1,1]="-eq"
ifArray[0,1,2]="warto≈õƒá"
ifArray[0,1,3]="and"

ifArray[0,2,0]="pole"
ifArray[0,2,1]="-eq"
ifArray[0,2,2]="warto≈õƒá"
ifArray[0,2,3]=""

ifCondition="if [ "
for ((i=0;i<${#ifArray[@]};i++)); do
    for ((j=0;j<${#ifArray[$i]};j++)); do
        ifCondition+="${ifArray[$i,$j,$j]} ${ifArray[$i,$j,$j+1]} ${ifArray[$i,$j,$j+2]}"
        if [[ "${ifArray[$i,$j,$j+3]}" != "" ]]; then
            ifCondition+=" ] ${ifArray[$i,$j,$j+3]} [ "
        fi
    done
done
ifCondition+=" ]; then echo 'Warunek spe≈Çniony'; else echo 'Warunek niespe≈Çniony'; fi"

eval $ifCondition


-----
declare -A ifArray

ifArray[0,0,0]="pole"
ifArray[0,0,1]="-eq"
ifArray[0,0,2]="warto≈õƒá"
ifArray[0,0,3]="and"

ifArray[0,1,0]="pole"
ifArray[0,1,1]="-eq"
ifArray[0,1,2]="warto≈õƒá"
ifArray[0,1,3]="and"

ifArray[0,2,0]="pole"
ifArray[0,2,1]="-eq"
ifArray[0,2,2]="warto≈õƒá"
ifArray[0,2,3]=""

ifCondition="if [ "
for ((i=0;i<${#ifArray[@]};i++)); do
    ifCondition+="${ifArray[$i,$i,$i]} ${ifArray[$i,$i,$i+1]} ${ifArray[$i,$i,$i+2]}"
    if [[ "${ifArray[$i,$i,$i+3]}" != "" ]]; then
        ifCondition+=" ] ${ifArray[$i,$i,$i+3]} [ "
    fi
done
ifCondition+=" ]; then echo 'Warunek spe≈Çniony'; else echo 'Warunek niespe≈Çniony'; fi"

eval $ifCondition
---------------
#!/bin/bash

matchingField[0][0]="pole"
condition[0][0]="-eq"
pattern[0][0]="warto≈õƒá"
rule[0][0]="and"
matchingField[0][1]="pole"
condition[0][1]="-eq"
pattern[0][1]="warto≈õƒá"
rule[0][1]="and"
matchingField[0][2]="pole"
condition[0][2]="-eq"
pattern[0][2]="warto≈õƒá"
rule[0][2]=""

matchingField[1][0]="pole"
condition[1][0]="-eq"
pattern[1][0]="warto≈õƒá"
rule[1][0]="and"
matchingField[1][1]="pole"
condition[1][1]="-eq"
pattern[1][1]="warto≈õƒá"
rule[1][1]="and"
matchingField[1][2]="pole"
condition[1][2]="-eq"
pattern[1][2]="warto≈õƒá"
rule[1][2]=""

matchingField[2][0]="pole"
condition[2][0]="-eq"
pattern[2][0]="warto≈õƒá"
rule[2][0]="and"
matchingField[2][1]="pole"
condition[2][1]="-eq"
pattern[2][1]="warto≈õƒá"
rule[2][1]=""

matchingField[3][0]="pole"
condition[3][0]="-eq"
pattern[3][0]="warto≈õƒá"
rule[3][0]=""


ifCondition="if [ "
for ((i=0;i<${#matchingField[@]};i++)); do
    for ((j=0;j<${#matchingField[$i]};j++)); do
        ifCondition+="${matchingField[$i][$j]} ${condition[$i][$j]} ${pattern[$i][$j]}"
        if [[ "${rule[$i][$j]}" != "" ]]; then
            ifCondition+=" ] ${rule[$i][$j]} [ "
        fi
    done
    if [[ $i -lt $((${#matchingField[@]} - 1)) ]]; then
        ifCondition+=" ] || [ "
    fi
done
ifCondition+=" ]; then echo 'Warunek spe≈Çniony'; else echo 'Warunek niespe≈Çniony'; fi"

eval $ifCondition
--------------------------------------
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "field1": "value1"
          }
        },
        {
          "match": {
            "field2": {
              "query": "value2",
              "fuzziness": "AUTO"
            }
          }
        }
      ]
    }
  }
}

---------------------
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "field1": "value1"
          }
        },
        {
          "wildcard": {
            "field2": "*value2*"
          }
        }
      ]
    }
  }
}

---------------------------------------------------------------
GET /_search
{
  "query": {
    "bool": {
      "must": [
        {
          "wildcard": {
            "field1": "*value1*"
          }
        },
        {
          "wildcard": {
            "field2": "*value2*"
          }
        }
      ]
    }
  }
}
----------------------
GET /_search
{
  "query": {
    "bool": {
      "must": [
        {
          "wildcard": {
            "field1": "*value1*"
          }
        },
        {
          "wildcard": {
            "field2": "*value2*"
          }
        }
      ]
    }
  }
}



####################################################################33
#!/bin/bash

file1="file1.txt"
file2="file2.txt"

echo "Linie z $file1, kt√≥re nie majƒÖ dopasowania w $file2:"
while read -r line1; do
  match=0
  while read -r line2; do
    if [[ "$line1" == "$line2" ]]; then
      match=1
      break
    fi
  done < "$file2"
  if [[ $match -eq 0 ]]; then
    echo "$line1"
  fi
done < "$file1"

echo "Linie z $file2, kt√≥re nie majƒÖ dopasowania w $file1:"
while read -r line2; do
  match=0
  while read -r line1; do
    if [[ "$line2" == "$line1" ]]; then
      match=1
      break
    fi
  done < "$file1"
  if [[ $match -eq 0 ]]; then
    echo "$line2"
  fi
done < "$file2"
