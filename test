# ile procesów controller wystawia metryki
present_sum = sum by () (count by (instance) (jvm_info{instance=~"60\.10\.10\.(10|11|12):21005"}))

# suma active controller (dopasuj do wersji: legacy vs KRaft)
active_sum = sum by () (
  max by (instance) (
    (kafka_controller_kafkacontroller_activecontrollercount{instance=~"60\.10\.10\.(10|11|12):21005"})
    or
    (kafka_controller_controllerquorum_activecontrollercount{instance=~"60\.10\.10\.(10|11|12):21005"})
  )
)

3 * (active_sum >= bool 2)
+
2 * ((active_sum == bool 1) and (present_sum >= bool 3))
+
1 * ((active_sum == bool 1) and (present_sum <= bool 2))
+
0 * (active_sum == bool 0)

------------------------------------------

sum by () (
  (
    max by (instance) (kafka_server_kafkaserver_brokerstate{instance=~"50\.10\.10\.(10|11|12):21005"} >= bool 3)
  *
    (
      max by (instance) (kafka_server_replicamanager_underreplicatedpartitions{instance=~"50\.10\.10\.(10|11|12):21005"} == bool 0)
      or on (instance) (max by (instance) (jvm_info{instance=~"50\.10\.10\.(10|11|12):21005"} * 0 + 1))
    )
  *
    (
      (sum by (instance) (increase(kafka_server_brokertopicmetrics_failedproducerequestspersec{instance=~"50\.10\.10\.(10|11|12):21005"}[5m])) == bool 0)
      or on (instance) (max by (instance) (jvm_info{instance=~"50\.10\.10\.(10|11|12):21005"} * 0 + 1))
    )
  *
    (
      (sum by (instance) (increase(kafka_server_brokertopicmetrics_failedfetchrequestspersec{instance=~"50\.10\.10\.(10|11|12):21005"}[5m])) == bool 0)
      or on (instance) (max by (instance) (jvm_info{instance=~"50\.10\.10\.(10|11|12):21005"} * 0 + 1))
    )
  )
  or on (instance)
    (max by (instance) (jvm_info{instance=~"50\.10\.10\.(10|11|12):21005"} * 0))
)


-----------------------
sum by () (
  (
    (count by (instance) (thanos_build_info{instance=~"20\.20\.20\.20:19090|20\.20\.20\.21:19090"}) > bool 0)
  *
    (
      max by (instance) (thanos_sidecar_prometheus_up{instance=~"20\.20\.20\.20:19090|20\.20\.20\.21:19090"} == bool 1)
      or on (instance) (max by (instance) (up{instance=~"20\.20\.20\.20:19090|20\.20\.20\.21:19090"} * 0 + 1))
    )
  *
    (
      (sum by (instance) (
        increase(grpc_server_handled_total{
          instance=~"20\.20\.20\.20:19090|20\.20\.20\.21:19090",
          grpc_code!="OK",
          grpc_service="thanos.Store"
        }[15m])
      ) == bool 0)
      or on (instance) (max by (instance) (up{instance=~"20\.20\.20\.20:19090|20\.20\.20\.21:19090"} * 0 + 1))
    )
  *
    (
      (sum by (instance) (increase(thanos_shipper_upload_failures_total{instance=~"20\.20\.20\.20:19090|20\.20\.20\.21:19090"}[30m])) == bool 0)
      or on (instance) (max by (instance) (up{instance=~"20\.20\.20\.20:19090|20\.20\.20\.21:19090"} * 0 + 1))
    )
  *
    (
      (sum by (instance) (increase(thanos_objstore_bucket_operation_failures_total{instance=~"20\.20\.20\.20:19090|20\.20\.20\.21:19090"}[30m])) == bool 0)
      or on (instance) (max by (instance) (up{instance=~"20\.20\.20\.20:19090|20\.20\.20\.21:19090"} * 0 + 1))
    )
  )
  or on (instance)
    (max by (instance) (up{instance=~"20\.20\.20\.20:19090|20\.20\.20\.21:19090"} * 0))
)

-------------------
sum by () (
(
(count by (instance) (thanos_build_info{instance=~"15\.10\.10\.10:9090|15\.10\.10\.11:9090"}) > bool 0)
(
max by (instance) (
increase(grpc_client_handled_total{
instance="15\.10\.10\.10:9090|15\.10\.10\.11:9090",
grpc_service="thanos.Store",
grpc_code!="OK"
}[15m]) == bool 0
)
or on (instance)
(max by (instance) (up{instance="15\.10\.10\.10:9090|15\.10\.10\.11:9090"}) * 0 + 1)
)
)
or on (instance)
(max by (instance) (up{instance=~"15\.10\.10\.10:9090|15\.10\.10\.11:9090"}) * 0)
)

-----------------------------------
# Ri: 0/1 per instancja — czy proces wystawia metryki (build_info)
# Hi: 0/1 per instancja — czy instancja jest halted (brak metryki => 0 dla działającej instancji)
# r  = suma Ri (0..2)       — ile instancji działa
# hr = suma (Ri * Hi) (0..2)— ile działających instancji jest halted

# Zbiorcze liczniki z fallbackiem do 0 (or vector(0)):
(
  3 * ( (sum by () ( count by (instance) (thanos_build_info{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) > bool 0 ) >= bool 2 ) or vector(0) )
)
+
(
  # część na przypadek „działa dokładnie 1 instancja”
  ( (sum by () ( count by (instance) (thanos_build_info{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) > bool 0 )) == bool 1 or vector(0) )
  *
  (
    # zlicz działające instancje, które są halted: hr = sum(Ri * Hi)
    # Hi z fallbackiem do 0 dla działających instancji, jeśli metryka halted nie istnieje
    2 * (
      (
        sum by () (
          ( count by (instance) (thanos_build_info{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) > bool 0 )
          *
          (
            (
              max by (instance) (thanos_compact_halted{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"} > bool 0)
            )
            or on (instance)
            (
              ( count by (instance) (thanos_build_info{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) > bool 0 ) * 0
            )
          )
        )
      ) == bool 0
      or vector(0)
    )
    +
    1 * (
      (
        sum by () (
          ( count by (instance) (thanos_build_info{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) > bool 0 )
          *
          (
            (
              max by (instance) (thanos_compact_halted{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"} > bool 0)
            )
            or on (instance)
            (
              ( count by (instance) (thanos_build_info{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) > bool 0 ) * 0
            )
          )
        )
      ) >= bool 1
      or vector(0)
    )
  )
)



------------------------
3 * (
  max by () (
    max by (instance) (thanos_compact_halted{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"} > bool 0)
  ) or vector(0)
)
+
(1 - (
  max by () (
    max by (instance) (thanos_compact_halted{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"} > bool 0)
  ) or vector(0)
))
*
(
  (sum by () (
    (
      (count by (instance) (thanos_build_info{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) > bool 0)
    *
      (1 - (
        max by (instance) (thanos_compact_halted{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"} > bool 0)
        or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0)
      ))
    *
      (
        max by (instance) (
          increase(thanos_compact_group_compactions_total{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902",result="error"}[15m]) == bool 0
        )
        or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0 + 1)
      )
    *
      (
        max by (instance) (
          increase(thanos_objstore_bucket_operation_failures_total{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}[15m]) == bool 0
        )
        or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0 + 1)
      )
    )
    or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0)
  ) >= bool 1)
  +
  (sum by () (
    (
      (count by (instance) (thanos_build_info{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) > bool 0)
    *
      (1 - (
        max by (instance) (thanos_compact_halted{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"} > bool 0)
        or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0)
      ))
    *
      (
        max by (instance) (
          increase(thanos_compact_group_compactions_total{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902",result="error"}[15m]) == bool 0
        )
        or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0 + 1)
      )
    *
      (
        max by (instance) (
          increase(thanos_objstore_bucket_operation_failures_total{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}[15m]) == bool 0
        )
        or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0 + 1)
      )
    )
    or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0)
  ) >= bool 2)
)


-----------------------------------------
# halted_i: 0/1 per instancja
(
  (max by (instance) (thanos_compact_halted{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"} > bool 0))
  or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0)
)  * 2
+
# ok_i: 0/1 per instancja (tylko jeśli NIE jest halted)
(1 -
  ( (max by (instance) (thanos_compact_halted{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"} > bool 0))
    or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0)
  )
)
*
(
  (
    (count by (instance) (thanos_build_info{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) > bool 0)
  *
    (
      (max by (instance) (increase(thanos_compact_group_compactions_total{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902", result="error"}[15m]) == bool 0))
      or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0 + 1)
    )
  *
    (
      (max by (instance) (increase(thanos_objstore_bucket_operation_failures_total{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}[15m]) == bool 0))
      or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0 + 1)
    )
  )
  or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0)
)



---------------------------------------------
# any_halted: 1 gdy którakolwiek instancja ma halted
(
  max by () (
    (max by (instance) (thanos_compact_halted{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"} > bool 0))
    or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0)
  )
) as any_halted

# ok_count: 0..2 – ile instancji jest OK wg warunków
+
sum by () (
  (
    (count by (instance) (thanos_build_info{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) > bool 0)
  *
    (
      (max by (instance) (thanos_compact_halted{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"} == bool 0))
      or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0 + 1)
    )
  *
    (
      (max by (instance) (increase(thanos_compact_group_compactions_total{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902", result="error"}[15m]) == bool 0))
      or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0 + 1)
    )
  *
    (
      (max by (instance) (increase(thanos_objstore_bucket_operation_failures_total{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}[15m]) == bool 0))
      or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0 + 1)
    )
  )
  or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0)
) as ok_count

# ostateczny status 0/1/2/3:
# 3*any_halted + (1-any_halted)*( 2*(ok_count==2) + 1*(ok_count==1) )
+
3 * any_halted
+
(1 - any_halted) * (
  2 * (ok_count == bool 2)
  + 1 * (ok_count == bool 1)
)


-------------------------
# Wzorzec instancji (IP:port) – kropki muszą być escapowane
sum by () (
  (
    # OK per instancja = 1, jeśli: jest build_info, nie jest halted, brak błędów kompaktacji i bucket ops w ostatnich 15m
    (
      (count by (instance) (thanos_build_info{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) > bool 0)
    *
      (
        (max by (instance) (thanos_compact_halted{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"} == bool 0))
        or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0 + 1)
      )
    *
      (
        (max by (instance) (increase(thanos_compact_group_compactions_total{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902", result="error"}[15m]) == bool 0))
        or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0 + 1)
      )
    *
      (
        (max by (instance) (increase(thanos_objstore_bucket_operation_failures_total{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}[15m]) == bool 0))
        or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0 + 1)
      )
    )
    or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0)
  )
) as ok_count
+
3 * (
  max by () (
    (
      (max by (instance) (thanos_compact_halted{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"} > bool 0))
      or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) * 0)
    )
  )
)
*
0  # (to obejście składniowe aby zdefiniować etykietę — patrz niżej)



---------------------------------------
(
  sum by () (
    (
      (count by (instance) (thanos_build_info{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}) > bool 0)
    *
      (
        (max by (instance) (increase(thanos_compact_group_compactions_total{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902", result="error"}[15m]) == bool 0))
        or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"} * 0 + 1))
      )
    *
      (
        (max by (instance) (increase(thanos_objstore_bucket_operation_failures_total{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"}[15m]) == bool 0))
        or on (instance) (max by (instance) (up{instance=~"12\\.10\\.10\\.10:10902|12\\.10\\.10\\.11:10902"} * 0 + 1))
      )
    )
  ) > bool 0
)

---------------
oniżej masz “jak to działa” i gotowe wzorce do wycięcia CN z DN w ssl.principal.mapping.rules na brokerze Kafka (KRaft lub ZK).

Co Kafka mapuje

Reguły działają na Subject DN certyfikatu klienta (kanoniczny format RFC2253), np.:
CN=Janek,OU=Team,O=Example,L=Warszawa,ST=Mazowieckie,C=PL
Mapowanie nie używa SAN – tylko DN.
Gdzie ustawić

Globalnie (dla wszystkich listenerów):
ssl.principal.mapping.rules=...
Lub per-listener (nadpisuje globalne):
listener.name.<nazwa>.ssl.principal.mapping.rules=...
Pamiętaj o tym samym ustawieniu na wszystkich brokerach.
Najprostsza, najczęściej wystarczająca reguła (CN do małych liter)

Wytnie wszystko, co po CN= aż do pierwszego przecinka:
ssl.principal.mapping.rules=RULE:^.CN=([^,]+).$/$1/L,DEFAULT
Efekt: CN=Janek → principal “janek” (L = lowercase)
Bardziej odporna (CN może mieć przecinki escapowane “, …”)

W properties musisz podwoić backslashe.
Reguła “escapowane znaki lub cokolwiek poza przecinkiem”:
ssl.principal.mapping.rules=RULE:^.CN=((?:\\.|[^,]))\s*(?:,.*)?$/$1/L,DEFAULT
Wyjaśnienie:
(?:\\.|[^,])* → dopasuj sekwencję “\x” lub każdy znak poza przecinkiem
/L → wynik na małe litery
W pliku .properties backslash trzeba podwoić (\\, by trafił do Javy jako \
Przykłady innych transformacji

CN+OU → “ou_cn”, małymi:
ssl.principal.mapping.rules=RULE:^.CN=([^,]+),OU=([^,]+).$/$2_$1/L,DEFAULT
Jeśli chcesz zachować wielkość liter: usuń /L.
Kilka reguł naraz

Kafka przetwarza je od lewej do prawej; pierwsza dopasowana wygrywa.
ssl.principal.mapping.rules=RULE:^.CN=([^,]+),OU=([^,]+).$/$2_$1/L,RULE:^.CN=([^,]+).$/$1/L,DEFAULT
Na co uważać

Escaping w .properties: jeśli używasz backslashy w regexie (np. \.), w pliku musisz je podwoić (\\.
Wynik mapowania musi 1:1 pasować do super.users/ACL (zwróć uwagę na /L → małe litery).
Mapowanie działa tylko przy SSL mTLS. Jeśli klient używa SASL_SSL, principal pochodzi z SASL (username), a nie z CN.
Jak sprawdzić, co broker faktycznie “widzi”

Włącz tymczasowo DEBUG loggerów (bez restartu):
kafka-configs.sh --bootstrap-server broker:port --alter
--entity-type broker-loggers --entity-name <brokerId>
--add-config 'org.apache.kafka.common.security.authenticator=DEBUG,kafka.authorizer.logger=DEBUG'
W server.log zobaczysz:
Authenticated client ... via SSL, principal=User:<wartość> ← to wpisujesz do super.users/ACL
Authorized/Denied ... for principal=User:<wartość> ← decyzje autoryzera
Po teście usuń/obniż logowanie:
kafka-configs.sh --bootstrap-server broker:port --alter
--entity-type broker-loggers --entity-name <brokerId>
--delete-config 'org.apache.kafka.common.security.authenticator,kafka.authorizer.logger'
Szybki “offline” podgląd DN (jak Kafka go formatuje)

openssl x509 -in client.crt.pem -noout -subject -nameopt RFC2253
subject=CN=Janek,OU=Team,O=Example,C=PL
Checklist końcowa

Ustaw regułę (globalnie lub per-listener) spójną na wszystkich brokerach.
Dopasuj super.users/ACL do wyniku (np. User:janek).
Upewnij się, że klient naprawdę używa mTLS (security.protocol=SSL oraz keystore/truststore ustawione) – w logu klienta z -Djavax.net.debug=ssl zobaczysz „Sending client certificate”.
Chcesz, żebym policzył dokładny principal dla konkretnego DN? Wklej swój DN (subject) i powiem, co zwróci każda z powyższych reguł.


----------------------------
ssl.principal.mapping.rules=RULE:^.CN=([^,]+).$/$1/L,DEFAULT

--------------------------
# rozbij na pojedyncze certy
csplit -s -f part- -b %02d.pem bundle.pem '/-----BEGIN CERTIFICATE-----/' '{*}'

# wypisz Subject/Issuer/ważność/BasicConstraints/EKU
for f in part-*.pem; do
  echo "=== $f ==="
  openssl x509 -in "$f" -noout -subject -issuer -enddate \
    -ext basicConstraints -ext extendedKeyUsage || true
done




cat int1.pem int2.pem > chain-clean.pem   # bez starego/wygasłego

# PKCS#12 z łańcuchem
openssl pkcs12 -export \
  -inkey client.key -in leaf.pem \
  -certfile chain-clean.pem -chain \
  -name client \
  -out client.p12 -passout pass:changeit


openssl pkcs12 -in client.p12 -nokeys -clcerts -info -passin pass:changeit | openssl x509 -noout -subject -issuer



keytool -importkeystore \
  -srckeystore client.p12 -srcstoretype PKCS12 -srcstorepass changeit \
  -destkeystore keystore.jks -deststoretype JKS -deststorepass changeit \
  -alias client

# sprawdź, że jest PrivateKeyEntry i chain > 1
keytool -list -v -keystore keystore.jks -storepass changeit -alias client | \
  egrep 'Entry type:|Certificate chain length:|Owner:|Issuer:'


---------------------------------------
#!/usr/bin/env bash
set -Eeuo pipefail

usage() {
  cat <<EOF
Użycie: $0 -k <keystore> [-t JKS|PKCS12] [-p <hasło>] [-w <dni_ostrzeżenia>]
Przykład: $0 -k keystore.jks -t JKS
EOF
}

KS="" ; TYPE="" ; PASS="" ; WARN_DAYS=30
while [[ $# -gt 0 ]]; do
  case "$1" in
    -k|--keystore) KS="$2"; shift 2;;
    -t|--type)     TYPE="$2"; shift 2;;
    -p|--password) PASS="$2"; shift 2;;
    -w|--warn)     WARN_DAYS="$2"; shift 2;;
    -h|--help)     usage; exit 0;;
    *) echo "Nieznany parametr: $1" >&2; usage; exit 1;;
  esac
done

[[ -z "$KS" ]] && { echo "Podaj -k <keystore>" >&2; usage; exit 1; }
command -v keytool >/dev/null || { echo "Brak keytool w PATH" >&2; exit 1; }
if ! command -v openssl >/dev/null; then
  echo "Uwaga: brak openssl – część pól będzie ograniczona." >&2
fi

# Domyśl rozpoznanie typu po rozszerzeniu, jeśli nie podano
if [[ -z "$TYPE" ]]; then
  case "${KS##*.}" in
    jks|JKS) TYPE="JKS" ;;
    p12|P12|pfx|PFX) TYPE="PKCS12" ;;
    *) TYPE="" ;; # keytool spróbuje sam
  esac
fi

# Hasło – poproś jeśli nie podane
if [[ -z "$PASS" ]]; then
  read -r -s -p "Hasło do keystore: " PASS; echo
fi

export LC_ALL=C

KT_ARGS=(-keystore "$KS" -storepass "$PASS")
[[ -n "$TYPE" ]] && KT_ARGS+=(-storetype "$TYPE")

# Sprawdź dostęp
if ! keytool -list "${KT_ARGS[@]}" >/dev/null 2>&1; then
  echo "Błąd: nieprawidłowe hasło/typ/plik (albo keystore uszkodzony)" >&2
  exit 1
fi

# Pobierz aliasy
mapfile -t ALIASES < <(keytool -list -v "${KT_ARGS[@]}" 2>/dev/null | awk -F': ' '/^Alias name:/{print $2}')
if [[ ${#ALIASES[@]} -eq 0 ]]; then
  echo "Brak aliasów w keystore lub brak uprawnień." >&2
  exit 0
fi

NOW_EPOCH=$(date +%s)

for alias in "${ALIASES[@]}"; do
  META=$(keytool -list -v -alias "$alias" "${KT_ARGS[@]}" 2>/dev/null || true)
  ENTRY_TYPE=$(awk -F': ' '/^Entry type:/{print $2}' <<<"$META")
  CHAIN_LEN=$(awk -F': ' '/^Certificate chain length:/{print $2}' <<<"$META")
  [[ -z "$CHAIN_LEN" ]] && CHAIN_LEN=1

  echo "----------------------------------------"
  echo "Alias:        $alias"
  echo "Typ wpisu:    ${ENTRY_TYPE:-nieznany}"
  echo "Dł. łańcucha: $CHAIN_LEN"

  if command -v openssl >/dev/null; then
    # wyeksportuj cert (leaf) i wypisz parametry
    if PEM=$(keytool -exportcert -alias "$alias" "${KT_ARGS[@]}" -rfc 2>/dev/null); then
      SUBJECT=$(openssl x509 -noout -subject    <<<"$PEM" | sed 's/^subject= //')
      ISSUER=$(openssl  x509 -noout -issuer     <<<"$PEM" | sed 's/^issuer= //')
      NB=$(openssl      x509 -noout -startdate  <<<"$PEM" | cut -d= -f2)
      NA=$(openssl      x509 -noout -enddate    <<<"$PEM" | cut -d= -f2)
      SERIAL=$(openssl  x509 -noout -serial     <<<"$PEM" | cut -d= -f2)
      FP=$(openssl      x509 -noout -fingerprint -sha256 <<<"$PEM" | cut -d= -f2)

      echo "Subject:      $SUBJECT"
      echo "Issuer:       $ISSUER"
      echo "Serial:       $SERIAL"
      echo "Not Before:   $NB"
      echo "Not After:    $NA"

      # policz dni do wygaśnięcia (GNU date)
      if END_EPOCH=$(date -d "$NA" +%s 2>/dev/null); then
        DAYS_LEFT=$(( (END_EPOCH - NOW_EPOCH) / 86400 ))
        echo "Pozostało:    ${DAYS_LEFT} dni"
        if (( DAYS_LEFT <= WARN_DAYS )); then
          echo "UWAGA: certyfikat wygaśnie w ${DAYS_LEFT} dni!"
        fi
      fi
      echo "SHA256 FP:    $FP"
    else
      echo "Nie udało się wyeksportować certyfikatu (alias: $alias)."
    fi
  else
    # Fallback bez openssl – ograniczone info z keytool -list -v
    echo "$(sed -n -e 's/^Owner: \+//p' -e 's/^Subject: \+//p' -e 's/^Issuer: \+//p' -e 's/^Serial number: \+//p' -e 's/^Valid from: \+//p' <<<"$META")"
  fi
done
------------------
#!/bin/bash

VAULT_ADDR="http://vault.example.com:8200"
VAULT_USER="twoj_uzytkownik"
VAULT_PASS="twoje_haslo"
SECRET_PATH="secret/data/mysecret"  # zmień jeśli KV v1 na: secret/mysecret

# 1. Logowanie
VAULT_TOKEN=$(curl -s \
  --request POST \
  --data "{\"password\": \"${VAULT_PASS}\"}" \
  "${VAULT_ADDR}/v1/auth/userpass/login/${VAULT_USER}" \
  | jq -r '.auth.client_token')

if [ -z "$VAULT_TOKEN" ] || [ "$VAULT_TOKEN" == "null" ]; then
  echo "❌ Błąd: nie udało się pobrać tokena" >&2
  exit 1
fi

echo "✅ Token pobrany: $VAULT_TOKEN"

# 2. Pobranie sekretu
RESPONSE=$(curl -s \
  -H "X-Vault-Token: ${VAULT_TOKEN}" \
  "${VAULT_ADDR}/v1/${SECRET_PATH}")

echo "🔍 Pełna odpowiedź z Vault:"
echo "$RESPONSE" | jq .

# 3. Jeśli KV v2 - same dane:
if [[ "$SECRET_PATH" == *"data/"* ]]; then
  echo "📦 Dane sekreta:"
  echo "$RESPONSE" | jq -r '.data.data'
fi


------
max(
  (
    (kafka_server_BrokerState{instance="broker1:7071"} >= 0)
    and on (instance) (rate(kafka_server_BrokerTopicMetrics_BytesInTotal{instance="broker1:7071"}[5m]) > 0)
    > bool 0
  )
  or on() (absent(kafka_server_BrokerState{instance="broker1:7071"}) * 0)
)

--

max(
  (
    (kafka_controller_ControllerStats_activeControllerCount{instance="controller1:7071"} >= 0)
    and on (instance) (rate(kafka_server_BrokerTopicMetrics_BytesInTotal{instance="controller1:7071"}[5m]) > 0)
    > bool 0
  )
  or on() (absent(kafka_controller_ControllerStats_activeControllerCount{instance="controller1:7071"}) * 0)
)

--------------------------------


(prometheus_build_info{job="prometheus"} == 1)
and (process_start_time_seconds{job="prometheus"} > 0)
and (increase(prometheus_tsdb_head_samples_appended_total{job="prometheus"}[5m]) > 0)
and (increase(prometheus_target_scrapes_total{job="prometheus"}[5m]) > 0)
--------------------
#!/bin/bash
# Skrypt: pokazuje szczegóły wszystkich certyfikatów w pliku PEM
# Użycie: ./show_certs.sh plik.pem

# Sprawdzenie argumentów
if [ $# -ne 1 ]; then
    echo "Użycie: $0 plik_z_cert.pem"
    exit 1
fi

CERT_FILE="$1"

# Sprawdzenie czy plik istnieje
if [ ! -f "$CERT_FILE" ]; then
    echo "Błąd: plik '$CERT_FILE' nie istnieje"
    exit 1
fi

# Przetwarzanie certyfikatów po kolei
csplit -f cert_part_ -b "%02d.pem" "$CERT_FILE" '/-----BEGIN CERTIFICATE-----/' '{*}' > /dev/null 2>&1

for cert in cert_part_*.pem; do
    if grep -q "BEGIN CERTIFICATE" "$cert"; then
        echo "========== Certyfikat: $cert =========="
        openssl x509 -noout -text -in "$cert"
        echo ""  # pusty wiersz między certyfikatami
    fi
    rm -f "$cert"  # usuwanie pliku tymczasowego
done
-------------
#!/bin/bash

# Parametry (możesz przekazać jako zmienne środowiskowe lub argumenty)
CERT="server.crt"
KEY="server.key"
CA="ca.crt"
P12="server.p12"
P12_ALIAS="myserver"
P12_PASS="p12haslo"
KEYSTORE="keystore.jks"
KEYSTORE_PASS="keystorehaslo"
TRUSTSTORE="truststore.jks"
TRUSTSTORE_PASS="truststorehaslo"
TRUSTSTORE_ALIAS="myca"

# 1. Tworzenie PKCS#12
openssl pkcs12 -export \
  -in "$CERT" \
  -inkey "$KEY" \
  -certfile "$CA" \
  -name "$P12_ALIAS" \
  -out "$P12" \
  -password pass:"$P12_PASS"

echo "PKCS#12 zapisany jako $P12"

# 2. Tworzenie keystore JKS z PKCS#12
keytool -importkeystore \
  -deststorepass "$KEYSTORE_PASS" \
  -destkeypass "$KEYSTORE_PASS" \
  -destkeystore "$KEYSTORE" \
  -srckeystore "$P12" \
  -srcstoretype PKCS12 \
  -srcstorepass "$P12_PASS" \
  -alias "$P12_ALIAS" \
  -noprompt

echo "Keystore JKS zapisany jako $KEYSTORE"

# 3. Tworzenie truststore JKS i import CA
keytool -importcert \
  -trustcacerts \
  -alias "$TRUSTSTORE_ALIAS" \
  -file "$CA" \
  -keystore "$TRUSTSTORE" \
  -storepass "$TRUSTSTORE_PASS" \
  -noprompt

echo "Truststore JKS zapisany jako $TRUSTSTORE"
