oniżej masz “jak to działa” i gotowe wzorce do wycięcia CN z DN w ssl.principal.mapping.rules na brokerze Kafka (KRaft lub ZK).

Co Kafka mapuje

Reguły działają na Subject DN certyfikatu klienta (kanoniczny format RFC2253), np.:
CN=Janek,OU=Team,O=Example,L=Warszawa,ST=Mazowieckie,C=PL
Mapowanie nie używa SAN – tylko DN.
Gdzie ustawić

Globalnie (dla wszystkich listenerów):
ssl.principal.mapping.rules=...
Lub per-listener (nadpisuje globalne):
listener.name.<nazwa>.ssl.principal.mapping.rules=...
Pamiętaj o tym samym ustawieniu na wszystkich brokerach.
Najprostsza, najczęściej wystarczająca reguła (CN do małych liter)

Wytnie wszystko, co po CN= aż do pierwszego przecinka:
ssl.principal.mapping.rules=RULE:^.CN=([^,]+).$/$1/L,DEFAULT
Efekt: CN=Janek → principal “janek” (L = lowercase)
Bardziej odporna (CN może mieć przecinki escapowane “, …”)

W properties musisz podwoić backslashe.
Reguła “escapowane znaki lub cokolwiek poza przecinkiem”:
ssl.principal.mapping.rules=RULE:^.CN=((?:\\.|[^,]))\s*(?:,.*)?$/$1/L,DEFAULT
Wyjaśnienie:
(?:\\.|[^,])* → dopasuj sekwencję “\x” lub każdy znak poza przecinkiem
/L → wynik na małe litery
W pliku .properties backslash trzeba podwoić (\\, by trafił do Javy jako \
Przykłady innych transformacji

CN+OU → “ou_cn”, małymi:
ssl.principal.mapping.rules=RULE:^.CN=([^,]+),OU=([^,]+).$/$2_$1/L,DEFAULT
Jeśli chcesz zachować wielkość liter: usuń /L.
Kilka reguł naraz

Kafka przetwarza je od lewej do prawej; pierwsza dopasowana wygrywa.
ssl.principal.mapping.rules=RULE:^.CN=([^,]+),OU=([^,]+).$/$2_$1/L,RULE:^.CN=([^,]+).$/$1/L,DEFAULT
Na co uważać

Escaping w .properties: jeśli używasz backslashy w regexie (np. \.), w pliku musisz je podwoić (\\.
Wynik mapowania musi 1:1 pasować do super.users/ACL (zwróć uwagę na /L → małe litery).
Mapowanie działa tylko przy SSL mTLS. Jeśli klient używa SASL_SSL, principal pochodzi z SASL (username), a nie z CN.
Jak sprawdzić, co broker faktycznie “widzi”

Włącz tymczasowo DEBUG loggerów (bez restartu):
kafka-configs.sh --bootstrap-server broker:port --alter
--entity-type broker-loggers --entity-name <brokerId>
--add-config 'org.apache.kafka.common.security.authenticator=DEBUG,kafka.authorizer.logger=DEBUG'
W server.log zobaczysz:
Authenticated client ... via SSL, principal=User:<wartość> ← to wpisujesz do super.users/ACL
Authorized/Denied ... for principal=User:<wartość> ← decyzje autoryzera
Po teście usuń/obniż logowanie:
kafka-configs.sh --bootstrap-server broker:port --alter
--entity-type broker-loggers --entity-name <brokerId>
--delete-config 'org.apache.kafka.common.security.authenticator,kafka.authorizer.logger'
Szybki “offline” podgląd DN (jak Kafka go formatuje)

openssl x509 -in client.crt.pem -noout -subject -nameopt RFC2253
subject=CN=Janek,OU=Team,O=Example,C=PL
Checklist końcowa

Ustaw regułę (globalnie lub per-listener) spójną na wszystkich brokerach.
Dopasuj super.users/ACL do wyniku (np. User:janek).
Upewnij się, że klient naprawdę używa mTLS (security.protocol=SSL oraz keystore/truststore ustawione) – w logu klienta z -Djavax.net.debug=ssl zobaczysz „Sending client certificate”.
Chcesz, żebym policzył dokładny principal dla konkretnego DN? Wklej swój DN (subject) i powiem, co zwróci każda z powyższych reguł.


----------------------------
ssl.principal.mapping.rules=RULE:^.CN=([^,]+).$/$1/L,DEFAULT

--------------------------
# rozbij na pojedyncze certy
csplit -s -f part- -b %02d.pem bundle.pem '/-----BEGIN CERTIFICATE-----/' '{*}'

# wypisz Subject/Issuer/ważność/BasicConstraints/EKU
for f in part-*.pem; do
  echo "=== $f ==="
  openssl x509 -in "$f" -noout -subject -issuer -enddate \
    -ext basicConstraints -ext extendedKeyUsage || true
done




cat int1.pem int2.pem > chain-clean.pem   # bez starego/wygasłego

# PKCS#12 z łańcuchem
openssl pkcs12 -export \
  -inkey client.key -in leaf.pem \
  -certfile chain-clean.pem -chain \
  -name client \
  -out client.p12 -passout pass:changeit


openssl pkcs12 -in client.p12 -nokeys -clcerts -info -passin pass:changeit | openssl x509 -noout -subject -issuer



keytool -importkeystore \
  -srckeystore client.p12 -srcstoretype PKCS12 -srcstorepass changeit \
  -destkeystore keystore.jks -deststoretype JKS -deststorepass changeit \
  -alias client

# sprawdź, że jest PrivateKeyEntry i chain > 1
keytool -list -v -keystore keystore.jks -storepass changeit -alias client | \
  egrep 'Entry type:|Certificate chain length:|Owner:|Issuer:'


---------------------------------------
#!/usr/bin/env bash
set -Eeuo pipefail

usage() {
  cat <<EOF
Użycie: $0 -k <keystore> [-t JKS|PKCS12] [-p <hasło>] [-w <dni_ostrzeżenia>]
Przykład: $0 -k keystore.jks -t JKS
EOF
}

KS="" ; TYPE="" ; PASS="" ; WARN_DAYS=30
while [[ $# -gt 0 ]]; do
  case "$1" in
    -k|--keystore) KS="$2"; shift 2;;
    -t|--type)     TYPE="$2"; shift 2;;
    -p|--password) PASS="$2"; shift 2;;
    -w|--warn)     WARN_DAYS="$2"; shift 2;;
    -h|--help)     usage; exit 0;;
    *) echo "Nieznany parametr: $1" >&2; usage; exit 1;;
  esac
done

[[ -z "$KS" ]] && { echo "Podaj -k <keystore>" >&2; usage; exit 1; }
command -v keytool >/dev/null || { echo "Brak keytool w PATH" >&2; exit 1; }
if ! command -v openssl >/dev/null; then
  echo "Uwaga: brak openssl – część pól będzie ograniczona." >&2
fi

# Domyśl rozpoznanie typu po rozszerzeniu, jeśli nie podano
if [[ -z "$TYPE" ]]; then
  case "${KS##*.}" in
    jks|JKS) TYPE="JKS" ;;
    p12|P12|pfx|PFX) TYPE="PKCS12" ;;
    *) TYPE="" ;; # keytool spróbuje sam
  esac
fi

# Hasło – poproś jeśli nie podane
if [[ -z "$PASS" ]]; then
  read -r -s -p "Hasło do keystore: " PASS; echo
fi

export LC_ALL=C

KT_ARGS=(-keystore "$KS" -storepass "$PASS")
[[ -n "$TYPE" ]] && KT_ARGS+=(-storetype "$TYPE")

# Sprawdź dostęp
if ! keytool -list "${KT_ARGS[@]}" >/dev/null 2>&1; then
  echo "Błąd: nieprawidłowe hasło/typ/plik (albo keystore uszkodzony)" >&2
  exit 1
fi

# Pobierz aliasy
mapfile -t ALIASES < <(keytool -list -v "${KT_ARGS[@]}" 2>/dev/null | awk -F': ' '/^Alias name:/{print $2}')
if [[ ${#ALIASES[@]} -eq 0 ]]; then
  echo "Brak aliasów w keystore lub brak uprawnień." >&2
  exit 0
fi

NOW_EPOCH=$(date +%s)

for alias in "${ALIASES[@]}"; do
  META=$(keytool -list -v -alias "$alias" "${KT_ARGS[@]}" 2>/dev/null || true)
  ENTRY_TYPE=$(awk -F': ' '/^Entry type:/{print $2}' <<<"$META")
  CHAIN_LEN=$(awk -F': ' '/^Certificate chain length:/{print $2}' <<<"$META")
  [[ -z "$CHAIN_LEN" ]] && CHAIN_LEN=1

  echo "----------------------------------------"
  echo "Alias:        $alias"
  echo "Typ wpisu:    ${ENTRY_TYPE:-nieznany}"
  echo "Dł. łańcucha: $CHAIN_LEN"

  if command -v openssl >/dev/null; then
    # wyeksportuj cert (leaf) i wypisz parametry
    if PEM=$(keytool -exportcert -alias "$alias" "${KT_ARGS[@]}" -rfc 2>/dev/null); then
      SUBJECT=$(openssl x509 -noout -subject    <<<"$PEM" | sed 's/^subject= //')
      ISSUER=$(openssl  x509 -noout -issuer     <<<"$PEM" | sed 's/^issuer= //')
      NB=$(openssl      x509 -noout -startdate  <<<"$PEM" | cut -d= -f2)
      NA=$(openssl      x509 -noout -enddate    <<<"$PEM" | cut -d= -f2)
      SERIAL=$(openssl  x509 -noout -serial     <<<"$PEM" | cut -d= -f2)
      FP=$(openssl      x509 -noout -fingerprint -sha256 <<<"$PEM" | cut -d= -f2)

      echo "Subject:      $SUBJECT"
      echo "Issuer:       $ISSUER"
      echo "Serial:       $SERIAL"
      echo "Not Before:   $NB"
      echo "Not After:    $NA"

      # policz dni do wygaśnięcia (GNU date)
      if END_EPOCH=$(date -d "$NA" +%s 2>/dev/null); then
        DAYS_LEFT=$(( (END_EPOCH - NOW_EPOCH) / 86400 ))
        echo "Pozostało:    ${DAYS_LEFT} dni"
        if (( DAYS_LEFT <= WARN_DAYS )); then
          echo "UWAGA: certyfikat wygaśnie w ${DAYS_LEFT} dni!"
        fi
      fi
      echo "SHA256 FP:    $FP"
    else
      echo "Nie udało się wyeksportować certyfikatu (alias: $alias)."
    fi
  else
    # Fallback bez openssl – ograniczone info z keytool -list -v
    echo "$(sed -n -e 's/^Owner: \+//p' -e 's/^Subject: \+//p' -e 's/^Issuer: \+//p' -e 's/^Serial number: \+//p' -e 's/^Valid from: \+//p' <<<"$META")"
  fi
done
------------------
#!/bin/bash

VAULT_ADDR="http://vault.example.com:8200"
VAULT_USER="twoj_uzytkownik"
VAULT_PASS="twoje_haslo"
SECRET_PATH="secret/data/mysecret"  # zmień jeśli KV v1 na: secret/mysecret

# 1. Logowanie
VAULT_TOKEN=$(curl -s \
  --request POST \
  --data "{\"password\": \"${VAULT_PASS}\"}" \
  "${VAULT_ADDR}/v1/auth/userpass/login/${VAULT_USER}" \
  | jq -r '.auth.client_token')

if [ -z "$VAULT_TOKEN" ] || [ "$VAULT_TOKEN" == "null" ]; then
  echo "❌ Błąd: nie udało się pobrać tokena" >&2
  exit 1
fi

echo "✅ Token pobrany: $VAULT_TOKEN"

# 2. Pobranie sekretu
RESPONSE=$(curl -s \
  -H "X-Vault-Token: ${VAULT_TOKEN}" \
  "${VAULT_ADDR}/v1/${SECRET_PATH}")

echo "🔍 Pełna odpowiedź z Vault:"
echo "$RESPONSE" | jq .

# 3. Jeśli KV v2 - same dane:
if [[ "$SECRET_PATH" == *"data/"* ]]; then
  echo "📦 Dane sekreta:"
  echo "$RESPONSE" | jq -r '.data.data'
fi


------
max(
  (
    (kafka_server_BrokerState{instance="broker1:7071"} >= 0)
    and on (instance) (rate(kafka_server_BrokerTopicMetrics_BytesInTotal{instance="broker1:7071"}[5m]) > 0)
    > bool 0
  )
  or on() (absent(kafka_server_BrokerState{instance="broker1:7071"}) * 0)
)

--

max(
  (
    (kafka_controller_ControllerStats_activeControllerCount{instance="controller1:7071"} >= 0)
    and on (instance) (rate(kafka_server_BrokerTopicMetrics_BytesInTotal{instance="controller1:7071"}[5m]) > 0)
    > bool 0
  )
  or on() (absent(kafka_controller_ControllerStats_activeControllerCount{instance="controller1:7071"}) * 0)
)

--------------------------------


(prometheus_build_info{job="prometheus"} == 1)
and (process_start_time_seconds{job="prometheus"} > 0)
and (increase(prometheus_tsdb_head_samples_appended_total{job="prometheus"}[5m]) > 0)
and (increase(prometheus_target_scrapes_total{job="prometheus"}[5m]) > 0)
--------------------
#!/bin/bash
# Skrypt: pokazuje szczegóły wszystkich certyfikatów w pliku PEM
# Użycie: ./show_certs.sh plik.pem

# Sprawdzenie argumentów
if [ $# -ne 1 ]; then
    echo "Użycie: $0 plik_z_cert.pem"
    exit 1
fi

CERT_FILE="$1"

# Sprawdzenie czy plik istnieje
if [ ! -f "$CERT_FILE" ]; then
    echo "Błąd: plik '$CERT_FILE' nie istnieje"
    exit 1
fi

# Przetwarzanie certyfikatów po kolei
csplit -f cert_part_ -b "%02d.pem" "$CERT_FILE" '/-----BEGIN CERTIFICATE-----/' '{*}' > /dev/null 2>&1

for cert in cert_part_*.pem; do
    if grep -q "BEGIN CERTIFICATE" "$cert"; then
        echo "========== Certyfikat: $cert =========="
        openssl x509 -noout -text -in "$cert"
        echo ""  # pusty wiersz między certyfikatami
    fi
    rm -f "$cert"  # usuwanie pliku tymczasowego
done
-------------
#!/bin/bash

# Parametry (możesz przekazać jako zmienne środowiskowe lub argumenty)
CERT="server.crt"
KEY="server.key"
CA="ca.crt"
P12="server.p12"
P12_ALIAS="myserver"
P12_PASS="p12haslo"
KEYSTORE="keystore.jks"
KEYSTORE_PASS="keystorehaslo"
TRUSTSTORE="truststore.jks"
TRUSTSTORE_PASS="truststorehaslo"
TRUSTSTORE_ALIAS="myca"

# 1. Tworzenie PKCS#12
openssl pkcs12 -export \
  -in "$CERT" \
  -inkey "$KEY" \
  -certfile "$CA" \
  -name "$P12_ALIAS" \
  -out "$P12" \
  -password pass:"$P12_PASS"

echo "PKCS#12 zapisany jako $P12"

# 2. Tworzenie keystore JKS z PKCS#12
keytool -importkeystore \
  -deststorepass "$KEYSTORE_PASS" \
  -destkeypass "$KEYSTORE_PASS" \
  -destkeystore "$KEYSTORE" \
  -srckeystore "$P12" \
  -srcstoretype PKCS12 \
  -srcstorepass "$P12_PASS" \
  -alias "$P12_ALIAS" \
  -noprompt

echo "Keystore JKS zapisany jako $KEYSTORE"

# 3. Tworzenie truststore JKS i import CA
keytool -importcert \
  -trustcacerts \
  -alias "$TRUSTSTORE_ALIAS" \
  -file "$CA" \
  -keystore "$TRUSTSTORE" \
  -storepass "$TRUSTSTORE_PASS" \
  -noprompt

echo "Truststore JKS zapisany jako $TRUSTSTORE"
