oni≈ºej masz ‚Äújak to dzia≈Ça‚Äù i gotowe wzorce do wyciƒôcia CN z DN w ssl.principal.mapping.rules na brokerze Kafka (KRaft lub ZK).

Co Kafka mapuje

Regu≈Çy dzia≈ÇajƒÖ na Subject DN certyfikatu klienta (kanoniczny format RFC2253), np.:
CN=Janek,OU=Team,O=Example,L=Warszawa,ST=Mazowieckie,C=PL
Mapowanie nie u≈ºywa SAN ‚Äì tylko DN.
Gdzie ustawiƒá

Globalnie (dla wszystkich listener√≥w):
ssl.principal.mapping.rules=...
Lub per-listener (nadpisuje globalne):
listener.name.<nazwa>.ssl.principal.mapping.rules=...
Pamiƒôtaj o tym samym ustawieniu na wszystkich brokerach.
Najprostsza, najczƒô≈õciej wystarczajƒÖca regu≈Ça (CN do ma≈Çych liter)

Wytnie wszystko, co po CN= a≈º do pierwszego przecinka:
ssl.principal.mapping.rules=RULE:^.CN=([^,]+).$/$1/L,DEFAULT
Efekt: CN=Janek ‚Üí principal ‚Äújanek‚Äù (L = lowercase)
Bardziej odporna (CN mo≈ºe mieƒá przecinki escapowane ‚Äú, ‚Ä¶‚Äù)

W properties musisz podwoiƒá backslashe.
Regu≈Ça ‚Äúescapowane znaki lub cokolwiek poza przecinkiem‚Äù:
ssl.principal.mapping.rules=RULE:^.CN=((?:\\.|[^,]))\s*(?:,.*)?$/$1/L,DEFAULT
Wyja≈õnienie:
(?:\\.|[^,])* ‚Üí dopasuj sekwencjƒô ‚Äú\x‚Äù lub ka≈ºdy znak poza przecinkiem
/L ‚Üí wynik na ma≈Çe litery
W pliku .properties backslash trzeba podwoiƒá (\\, by trafi≈Ç do Javy jako \
Przyk≈Çady innych transformacji

CN+OU ‚Üí ‚Äúou_cn‚Äù, ma≈Çymi:
ssl.principal.mapping.rules=RULE:^.CN=([^,]+),OU=([^,]+).$/$2_$1/L,DEFAULT
Je≈õli chcesz zachowaƒá wielko≈õƒá liter: usu≈Ñ /L.
Kilka regu≈Ç naraz

Kafka przetwarza je od lewej do prawej; pierwsza dopasowana wygrywa.
ssl.principal.mapping.rules=RULE:^.CN=([^,]+),OU=([^,]+).$/$2_$1/L,RULE:^.CN=([^,]+).$/$1/L,DEFAULT
Na co uwa≈ºaƒá

Escaping w .properties: je≈õli u≈ºywasz backslashy w regexie (np. \.), w pliku musisz je podwoiƒá (\\.
Wynik mapowania musi 1:1 pasowaƒá do super.users/ACL (zwr√≥ƒá uwagƒô na /L ‚Üí ma≈Çe litery).
Mapowanie dzia≈Ça tylko przy SSL mTLS. Je≈õli klient u≈ºywa SASL_SSL, principal pochodzi z SASL (username), a nie z CN.
Jak sprawdziƒá, co broker faktycznie ‚Äúwidzi‚Äù

W≈ÇƒÖcz tymczasowo DEBUG logger√≥w (bez restartu):
kafka-configs.sh --bootstrap-server broker:port --alter
--entity-type broker-loggers --entity-name <brokerId>
--add-config 'org.apache.kafka.common.security.authenticator=DEBUG,kafka.authorizer.logger=DEBUG'
W server.log zobaczysz:
Authenticated client ... via SSL, principal=User:<warto≈õƒá> ‚Üê to wpisujesz do super.users/ACL
Authorized/Denied ... for principal=User:<warto≈õƒá> ‚Üê decyzje autoryzera
Po te≈õcie usu≈Ñ/obni≈º logowanie:
kafka-configs.sh --bootstrap-server broker:port --alter
--entity-type broker-loggers --entity-name <brokerId>
--delete-config 'org.apache.kafka.common.security.authenticator,kafka.authorizer.logger'
Szybki ‚Äúoffline‚Äù podglƒÖd DN (jak Kafka go formatuje)

openssl x509 -in client.crt.pem -noout -subject -nameopt RFC2253
subject=CN=Janek,OU=Team,O=Example,C=PL
Checklist ko≈Ñcowa

Ustaw regu≈Çƒô (globalnie lub per-listener) sp√≥jnƒÖ na wszystkich brokerach.
Dopasuj super.users/ACL do wyniku (np. User:janek).
Upewnij siƒô, ≈ºe klient naprawdƒô u≈ºywa mTLS (security.protocol=SSL oraz keystore/truststore ustawione) ‚Äì w logu klienta z -Djavax.net.debug=ssl zobaczysz ‚ÄûSending client certificate‚Äù.
Chcesz, ≈ºebym policzy≈Ç dok≈Çadny principal dla konkretnego DN? Wklej sw√≥j DN (subject) i powiem, co zwr√≥ci ka≈ºda z powy≈ºszych regu≈Ç.


----------------------------
ssl.principal.mapping.rules=RULE:^.CN=([^,]+).$/$1/L,DEFAULT

--------------------------
# rozbij na pojedyncze certy
csplit -s -f part- -b %02d.pem bundle.pem '/-----BEGIN CERTIFICATE-----/' '{*}'

# wypisz Subject/Issuer/wa≈ºno≈õƒá/BasicConstraints/EKU
for f in part-*.pem; do
  echo "=== $f ==="
  openssl x509 -in "$f" -noout -subject -issuer -enddate \
    -ext basicConstraints -ext extendedKeyUsage || true
done




cat int1.pem int2.pem > chain-clean.pem   # bez starego/wygas≈Çego

# PKCS#12 z ≈Ça≈Ñcuchem
openssl pkcs12 -export \
  -inkey client.key -in leaf.pem \
  -certfile chain-clean.pem -chain \
  -name client \
  -out client.p12 -passout pass:changeit


openssl pkcs12 -in client.p12 -nokeys -clcerts -info -passin pass:changeit | openssl x509 -noout -subject -issuer



keytool -importkeystore \
  -srckeystore client.p12 -srcstoretype PKCS12 -srcstorepass changeit \
  -destkeystore keystore.jks -deststoretype JKS -deststorepass changeit \
  -alias client

# sprawd≈∫, ≈ºe jest PrivateKeyEntry i chain > 1
keytool -list -v -keystore keystore.jks -storepass changeit -alias client | \
  egrep 'Entry type:|Certificate chain length:|Owner:|Issuer:'


---------------------------------------
#!/usr/bin/env bash
set -Eeuo pipefail

usage() {
  cat <<EOF
U≈ºycie: $0 -k <keystore> [-t JKS|PKCS12] [-p <has≈Ço>] [-w <dni_ostrze≈ºenia>]
Przyk≈Çad: $0 -k keystore.jks -t JKS
EOF
}

KS="" ; TYPE="" ; PASS="" ; WARN_DAYS=30
while [[ $# -gt 0 ]]; do
  case "$1" in
    -k|--keystore) KS="$2"; shift 2;;
    -t|--type)     TYPE="$2"; shift 2;;
    -p|--password) PASS="$2"; shift 2;;
    -w|--warn)     WARN_DAYS="$2"; shift 2;;
    -h|--help)     usage; exit 0;;
    *) echo "Nieznany parametr: $1" >&2; usage; exit 1;;
  esac
done

[[ -z "$KS" ]] && { echo "Podaj -k <keystore>" >&2; usage; exit 1; }
command -v keytool >/dev/null || { echo "Brak keytool w PATH" >&2; exit 1; }
if ! command -v openssl >/dev/null; then
  echo "Uwaga: brak openssl ‚Äì czƒô≈õƒá p√≥l bƒôdzie ograniczona." >&2
fi

# Domy≈õl rozpoznanie typu po rozszerzeniu, je≈õli nie podano
if [[ -z "$TYPE" ]]; then
  case "${KS##*.}" in
    jks|JKS) TYPE="JKS" ;;
    p12|P12|pfx|PFX) TYPE="PKCS12" ;;
    *) TYPE="" ;; # keytool spr√≥buje sam
  esac
fi

# Has≈Ço ‚Äì popro≈õ je≈õli nie podane
if [[ -z "$PASS" ]]; then
  read -r -s -p "Has≈Ço do keystore: " PASS; echo
fi

export LC_ALL=C

KT_ARGS=(-keystore "$KS" -storepass "$PASS")
[[ -n "$TYPE" ]] && KT_ARGS+=(-storetype "$TYPE")

# Sprawd≈∫ dostƒôp
if ! keytool -list "${KT_ARGS[@]}" >/dev/null 2>&1; then
  echo "B≈ÇƒÖd: nieprawid≈Çowe has≈Ço/typ/plik (albo keystore uszkodzony)" >&2
  exit 1
fi

# Pobierz aliasy
mapfile -t ALIASES < <(keytool -list -v "${KT_ARGS[@]}" 2>/dev/null | awk -F': ' '/^Alias name:/{print $2}')
if [[ ${#ALIASES[@]} -eq 0 ]]; then
  echo "Brak alias√≥w w keystore lub brak uprawnie≈Ñ." >&2
  exit 0
fi

NOW_EPOCH=$(date +%s)

for alias in "${ALIASES[@]}"; do
  META=$(keytool -list -v -alias "$alias" "${KT_ARGS[@]}" 2>/dev/null || true)
  ENTRY_TYPE=$(awk -F': ' '/^Entry type:/{print $2}' <<<"$META")
  CHAIN_LEN=$(awk -F': ' '/^Certificate chain length:/{print $2}' <<<"$META")
  [[ -z "$CHAIN_LEN" ]] && CHAIN_LEN=1

  echo "----------------------------------------"
  echo "Alias:        $alias"
  echo "Typ wpisu:    ${ENTRY_TYPE:-nieznany}"
  echo "D≈Ç. ≈Ça≈Ñcucha: $CHAIN_LEN"

  if command -v openssl >/dev/null; then
    # wyeksportuj cert (leaf) i wypisz parametry
    if PEM=$(keytool -exportcert -alias "$alias" "${KT_ARGS[@]}" -rfc 2>/dev/null); then
      SUBJECT=$(openssl x509 -noout -subject    <<<"$PEM" | sed 's/^subject= //')
      ISSUER=$(openssl  x509 -noout -issuer     <<<"$PEM" | sed 's/^issuer= //')
      NB=$(openssl      x509 -noout -startdate  <<<"$PEM" | cut -d= -f2)
      NA=$(openssl      x509 -noout -enddate    <<<"$PEM" | cut -d= -f2)
      SERIAL=$(openssl  x509 -noout -serial     <<<"$PEM" | cut -d= -f2)
      FP=$(openssl      x509 -noout -fingerprint -sha256 <<<"$PEM" | cut -d= -f2)

      echo "Subject:      $SUBJECT"
      echo "Issuer:       $ISSUER"
      echo "Serial:       $SERIAL"
      echo "Not Before:   $NB"
      echo "Not After:    $NA"

      # policz dni do wyga≈õniƒôcia (GNU date)
      if END_EPOCH=$(date -d "$NA" +%s 2>/dev/null); then
        DAYS_LEFT=$(( (END_EPOCH - NOW_EPOCH) / 86400 ))
        echo "Pozosta≈Ço:    ${DAYS_LEFT} dni"
        if (( DAYS_LEFT <= WARN_DAYS )); then
          echo "UWAGA: certyfikat wyga≈õnie w ${DAYS_LEFT} dni!"
        fi
      fi
      echo "SHA256 FP:    $FP"
    else
      echo "Nie uda≈Ço siƒô wyeksportowaƒá certyfikatu (alias: $alias)."
    fi
  else
    # Fallback bez openssl ‚Äì ograniczone info z keytool -list -v
    echo "$(sed -n -e 's/^Owner: \+//p' -e 's/^Subject: \+//p' -e 's/^Issuer: \+//p' -e 's/^Serial number: \+//p' -e 's/^Valid from: \+//p' <<<"$META")"
  fi
done
------------------
#!/bin/bash

VAULT_ADDR="http://vault.example.com:8200"
VAULT_USER="twoj_uzytkownik"
VAULT_PASS="twoje_haslo"
SECRET_PATH="secret/data/mysecret"  # zmie≈Ñ je≈õli KV v1 na: secret/mysecret

# 1. Logowanie
VAULT_TOKEN=$(curl -s \
  --request POST \
  --data "{\"password\": \"${VAULT_PASS}\"}" \
  "${VAULT_ADDR}/v1/auth/userpass/login/${VAULT_USER}" \
  | jq -r '.auth.client_token')

if [ -z "$VAULT_TOKEN" ] || [ "$VAULT_TOKEN" == "null" ]; then
  echo "‚ùå B≈ÇƒÖd: nie uda≈Ço siƒô pobraƒá tokena" >&2
  exit 1
fi

echo "‚úÖ Token pobrany: $VAULT_TOKEN"

# 2. Pobranie sekretu
RESPONSE=$(curl -s \
  -H "X-Vault-Token: ${VAULT_TOKEN}" \
  "${VAULT_ADDR}/v1/${SECRET_PATH}")

echo "üîç Pe≈Çna odpowied≈∫ z Vault:"
echo "$RESPONSE" | jq .

# 3. Je≈õli KV v2 - same dane:
if [[ "$SECRET_PATH" == *"data/"* ]]; then
  echo "üì¶ Dane sekreta:"
  echo "$RESPONSE" | jq -r '.data.data'
fi


------
max(
  (
    (kafka_server_BrokerState{instance="broker1:7071"} >= 0)
    and on (instance) (rate(kafka_server_BrokerTopicMetrics_BytesInTotal{instance="broker1:7071"}[5m]) > 0)
    > bool 0
  )
  or on() (absent(kafka_server_BrokerState{instance="broker1:7071"}) * 0)
)

--

max(
  (
    (kafka_controller_ControllerStats_activeControllerCount{instance="controller1:7071"} >= 0)
    and on (instance) (rate(kafka_server_BrokerTopicMetrics_BytesInTotal{instance="controller1:7071"}[5m]) > 0)
    > bool 0
  )
  or on() (absent(kafka_controller_ControllerStats_activeControllerCount{instance="controller1:7071"}) * 0)
)

--------------------------------


(prometheus_build_info{job="prometheus"} == 1)
and (process_start_time_seconds{job="prometheus"} > 0)
and (increase(prometheus_tsdb_head_samples_appended_total{job="prometheus"}[5m]) > 0)
and (increase(prometheus_target_scrapes_total{job="prometheus"}[5m]) > 0)
--------------------
#!/bin/bash
# Skrypt: pokazuje szczeg√≥≈Çy wszystkich certyfikat√≥w w pliku PEM
# U≈ºycie: ./show_certs.sh plik.pem

# Sprawdzenie argument√≥w
if [ $# -ne 1 ]; then
    echo "U≈ºycie: $0 plik_z_cert.pem"
    exit 1
fi

CERT_FILE="$1"

# Sprawdzenie czy plik istnieje
if [ ! -f "$CERT_FILE" ]; then
    echo "B≈ÇƒÖd: plik '$CERT_FILE' nie istnieje"
    exit 1
fi

# Przetwarzanie certyfikat√≥w po kolei
csplit -f cert_part_ -b "%02d.pem" "$CERT_FILE" '/-----BEGIN CERTIFICATE-----/' '{*}' > /dev/null 2>&1

for cert in cert_part_*.pem; do
    if grep -q "BEGIN CERTIFICATE" "$cert"; then
        echo "========== Certyfikat: $cert =========="
        openssl x509 -noout -text -in "$cert"
        echo ""  # pusty wiersz miƒôdzy certyfikatami
    fi
    rm -f "$cert"  # usuwanie pliku tymczasowego
done
-------------
#!/bin/bash

# Parametry (mo≈ºesz przekazaƒá jako zmienne ≈õrodowiskowe lub argumenty)
CERT="server.crt"
KEY="server.key"
CA="ca.crt"
P12="server.p12"
P12_ALIAS="myserver"
P12_PASS="p12haslo"
KEYSTORE="keystore.jks"
KEYSTORE_PASS="keystorehaslo"
TRUSTSTORE="truststore.jks"
TRUSTSTORE_PASS="truststorehaslo"
TRUSTSTORE_ALIAS="myca"

# 1. Tworzenie PKCS#12
openssl pkcs12 -export \
  -in "$CERT" \
  -inkey "$KEY" \
  -certfile "$CA" \
  -name "$P12_ALIAS" \
  -out "$P12" \
  -password pass:"$P12_PASS"

echo "PKCS#12 zapisany jako $P12"

# 2. Tworzenie keystore JKS z PKCS#12
keytool -importkeystore \
  -deststorepass "$KEYSTORE_PASS" \
  -destkeypass "$KEYSTORE_PASS" \
  -destkeystore "$KEYSTORE" \
  -srckeystore "$P12" \
  -srcstoretype PKCS12 \
  -srcstorepass "$P12_PASS" \
  -alias "$P12_ALIAS" \
  -noprompt

echo "Keystore JKS zapisany jako $KEYSTORE"

# 3. Tworzenie truststore JKS i import CA
keytool -importcert \
  -trustcacerts \
  -alias "$TRUSTSTORE_ALIAS" \
  -file "$CA" \
  -keystore "$TRUSTSTORE" \
  -storepass "$TRUSTSTORE_PASS" \
  -noprompt

echo "Truststore JKS zapisany jako $TRUSTSTORE"
