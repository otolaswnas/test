#!/bin/bash

# Ustawienie wartości dla zmiennej tablicowej suma_polityki
polityka="test-ilm"
fabryka_wielkosc="123"
suma_polityki["$polityka"]["wielkość"]=$fabryka_wielkosc

# Wypisanie wartości zmiennej tablicowej suma_polityki
echo "Wartość suma_polityki[$polityka][wielkość]: ${suma_polityki[$polityka][wielkość]}"




#!/bin/bash

# Ustawienie wartości dla zmiennej tablicowej suma_polityki
polityka="test-ilm"
fabryka_wielkosc="123"
suma_polityki["$polityka"]["wielkość"]=$fabryka_wielkosc

# Wypisanie wartości zmiennej tablicowej suma_polityki
echo "Wartość suma_polityki[$polityka][wielkość]: ${suma_polityki[$polityka][wielkość]}"




#!/bin/bash

# Przypisanie wartości dla zmiennych
polityka="test-ilm"
fabryka_wielkosc="123"

# Utworzenie tablicy suma_polityki i przypisanie wartości
declare -A suma_polityki
suma_polityki["$polityka"]=""
suma_polityki["$polityka"]["wielkość"]="$fabryka_wielkosc"

# Wyświetlenie wartości dla klucza $polityka i klucza wielkość
echo "${suma_polityki[$polityka][wielkość]}"



#!/bin/bash

# Ustawienie wartości dla zmiennej tablicowej
polityka="test-ilm"
fabryka_wielkosc="123"
suma_polityki["$polityka"]["wielkość"]=$fabryka_wielkosc

# Wypisanie wartości zmiennej
echo "Wartość zmiennej suma_polityki: ${suma_polityki[$polityka][wielkość]}"



# Wyświetlenie wyników jako JSON i zapis do pliku
for polityka in "${!wyniki_json[@]}"; do
    echo "\"$polityka\": ${wyniki_json["$polityka"]}"
done | jq -s . > wyniki.json
------------------
suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")

    suma_bajty_z_replika=${suma_polityk_z_replika["$polityka"]}
    suma_MB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024")
    suma_GB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024")
    suma_TB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024 / 1024")

    wyniki_json["$polityka"]='{"bez_repliki":{"Bajty":'$suma_bajty',"MB":'$suma_MB',"GB":'$suma_GB',"TB":'$suma_TB'},"z_replika":{"Bajty":'$suma_bajty_z_replika',"MB":'$suma_MB_z_replika',"GB":'$suma_GB_z_replika',"TB":'$suma_TB_z_replika'}}'

--------------------
#!/bin/bash
# Tworzymy asocjacyjny słownik, w którym kluczem jest nazwa polityki, a wartością suma wielkości w bajtach
declare -A suma_polityk
# Przetwarzamy dane linia po linii
while read -r line; do
    # Sprawdzamy, czy linia nie jest pusta
    if [[ -n "$line" ]]; then
        index=$(echo "$line" | jq -r '.indexname')
        polityka=$(echo "$line" | jq -r '.ilmname')
        wielkosc_index=$(echo "$line" | jq -r '.sizeindex')
        wielkosc_index_z_replika=$(echo "$line" | jq -r '.sizeindexwithreplica')

        # Dodajemy wielkości do sumy dla danej polityki
        suma_polityk["$polityka"]=$((suma_polityk["$polityka"] + wielkosc_index))
        suma_polityk_z_replika["$polityka"]=$((suma_polityk_z_replika["$polityka"] + wielkosc_index_z_replika))
    fi
done < plik_z_danymi.txt
for polityka in "${!suma_polityk[@]}"; do
    suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")
    echo "Suma wielkości dla polityki $polityka (bez repliki):"
    echo "  Bajty: $suma_bajty"
    echo "  MB: $suma_MB"
    echo "  GB: $suma_GB"
    echo "  TB: $suma_TB"
    suma_bajty_z_replika=${suma_polityk_z_replika["$polityka"]}
    suma_MB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024")
    suma_GB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024")
    suma_TB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024 / 1024")
    echo "Suma wielkości dla polityki $polityka (z repliką):"
    echo "  Bajty: $suma_bajty_z_replika"
    echo "  MB: $suma_MB_z_replika"
    echo "  GB: $suma_GB_z_replika"
    echo "  TB: $suma_TB_z_replika"
done


----------------------------------------------------------
#!/bin/bash
# Tworzymy asocjacyjny słownik, w którym kluczem jest nazwa polityki, a wartością suma wielkości w bajtach
declare -A suma_polityk
declare -A suma_polityk_z_replika

# Przetwarzamy dane linia po linii
while read -r line; do
    # Sprawdzamy, czy linia nie jest pusta
    if [[ -n "$line" ]]; then
        # Wyciągamy wartości index, polityka, wielkość index oraz wielkość index z repliką
        index=$(echo "$line" | jq -r '.indexname')
        polityka=$(echo "$line" | jq -r '.ilmname')
        wielkosc_index=$(echo "$line" | jq -r '.sizeindex')
        wielkosc_index_z_replika=$(echo "$line" | jq -r '.sizeindexwithreplica')

        # Dodajemy wielkości do sumy dla danej polityki
        suma_polityk["$polityka"]=$(bc <<< "${suma_polityk["$polityka"]} + $wielkosc_index")
        suma_polityk_z_replika["$polityka"]=$(bc <<< "${suma_polityk_z_replika["$polityka"]} + $wielkosc_index_z_replika")
    fi
done < plik_z_danymi.txt

# Wyświetlamy wyniki w różnych jednostkach
for polityka in "${!suma_polityk[@]}"; do
    suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielkości dla polityki $polityka (bez repliki):"
    echo "  Bajty: $suma_bajty"
    echo "  MB: $suma_MB"
    echo "  GB: $suma_GB"
    echo "  TB: $suma_TB"

    suma_bajty_z_replika=${suma_polityk_z_replika["$polityka"]}
    suma_MB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024")
    suma_GB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024")
    suma_TB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielkości dla polityki $polityka (z repliką):"
    echo "  Bajty: $suma_bajty_z_replika"
    echo "  MB: $suma_MB_z_replika"
    echo "  GB: $suma_GB_z_replika"
    echo "  TB: $suma_TB_z_replika"
done



-------------------------------------------
#!/bin/bash
# Tworzymy asocjacyjny słownik, w którym kluczem jest nazwa polityki, a wartością suma wielkości w bajtach
declare -A suma_polityk
declare -A suma_polityk_z_replika

# Przetwarzamy dane linia po linii
while read -r line; do
    # Sprawdzamy, czy linia nie jest pusta
    if [[ -n "$line" ]]; then
        # Wyciągamy wartości index, polityka, wielkość index oraz wielkość index z repliką
        index=$(echo "$line" | jq -r '.indexname')
        polityka=$(echo "$line" | jq -r '.ilmname')
        wielkosc_index=$(echo "$line" | jq -r '.sizeindex')
        wielkosc_index_z_replika=$(echo "$line" | jq -r '.sizeindexwithreplica')

        # Dodajemy wielkości do sumy dla danej polityki
        suma_polityk["$polityka"]=$(bc <<< "${suma_polityk["$polityka"]} + $wielkosc_index")
        suma_polityk_z_replika["$polityka"]=$(bc <<< "${suma_polityk_z_replika["$polityka"]} + $wielkosc_index_z_replika")
    fi
done < plik_z_danymi.txt

# Wyświetlamy wyniki w różnych jednostkach
for polityka in "${!suma_polityk[@]}"; do
    suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielkości dla polityki $polityka (bez repliki):"
    echo "  Bajty: $suma_bajty"
    echo "  MB: $suma_MB"
    echo "  GB: $suma_GB"
    echo "  TB: $suma_TB"

    suma_bajty_z_replika=${suma_polityk_z_replika["$polityka"]}
    suma_MB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024")
    suma_GB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024")
    suma_TB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielkości dla polityki $polityka (z repliką):"
    echo "  Bajty: $suma_bajty_z_replika"
    echo "  MB: $suma_MB_z_replika"
    echo "  GB: $suma_GB_z_replika"
    echo "  TB: $suma_TB_z_replika"
done

------------------------------------------------------------------------------------
#!/bin/bash
# Tworzymy asocjacyjny słownik, w którym kluczem jest nazwa polityki, a wartością suma wielkości w bajtach
declare -A suma_polityk

# Przetwarzamy dane linia po linii
while read -r line; do
    # Sprawdzamy, czy linia nie jest pusta
    if [[ -n "$line" ]]; then
        # Wyciągamy wartości index, polityka, wielkość index oraz wielkość index z repliką
        index=$(echo "$line" | jq -r '.indexname')
        polityka=$(echo "$line" | jq -r '.ilmname')
        wielkosc_index=$(echo "$line" | jq -r '.sizeindex')
        wielkosc_index_z_replika=$(echo "$line" | jq -r '.sizeindexwithreplica')

        # Dodajemy wielkości do sumy dla danej polityki
        suma_polityk["$polityka"]=$((suma_polityk["$polityka"] + wielkosc_index))
        suma_polityk_z_replika["$polityka"]=$((suma_polityk_z_replika["$polityka"] + wielkosc_index_z_replika))
    fi
done < plik_z_danymi.txt

# Wyświetlamy wyniki w różnych jednostkach
for polityka in "${!suma_polityk[@]}"; do
    suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielkości dla polityki $polityka (bez repliki):"
    echo "  Bajty: $suma_bajty"
    echo "  MB: $suma_MB"
    echo "  GB: $suma_GB"
    echo "  TB: $suma_TB"

    suma_bajty_z_replika=${suma_polityk_z_replika["$polityka"]}
    suma_MB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024")
    suma_GB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024")
    suma_TB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielkości dla polityki $polityka (z repliką):"
    echo "  Bajty: $suma_bajty_z_replika"
    echo "  MB: $suma_MB_z_replika"
    echo "  GB: $suma_GB_z_replika"
    echo "  TB: $suma_TB_z_replika"
done

-------------------------------------------------------------------------------------
#!/bin/bash

# Tworzymy asocjacyjny słownik, w którym kluczem jest nazwa polityki, a wartością suma wielkości w bajtach
declare -A suma_polityk

# Przetwarzamy dane linia po linii
while read -r line; do
    # Sprawdzamy, czy linia nie jest pusta
    if [[ -n "$line" ]]; then
        # Wyciągamy wartości index, polityka, wielkość index oraz wielkość index z repliką
        index=$(echo "$line" | jq -r '.indexname')
        polityka=$(echo "$line" | jq -r '.ilmname')
        wielkosc_index=$(echo "$line" | jq -r '.sizeindex')
        wielkosc_index_z_replika=$(echo "$line" | jq -r '.sizeindexwithreplica')

        # Dodajemy wielkości do sumy dla danej polityki
        suma_polityk["$polityka"]=$((suma_polityk["$polityka"] + wielkosc_index + wielkosc_index_z_replika))
    fi
done < plik_z_danymi.txt

# Wyświetlamy wyniki w różnych jednostkach
for polityka in "${!suma_polityk[@]}"; do
    suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielkości dla polityki $polityka:"
    echo "  Bajty: $suma_bajty"
    echo "  MB: $suma_MB"
    echo "  GB: $suma_GB"
    echo "  TB: $suma_TB"
done

# Obliczamy sumę wszystkich polityk w różnych jednostkach
suma_wszystkich_bajty=$(echo "${suma_polityk[@]}" | tr ' ' '+' | bc)
suma_wszystkich_MB=$(bc <<< "scale=2; $suma_wszystkich_bajty / 1024 / 1024")
suma_wszystkich_GB=$(bc <<< "scale=2; $suma_wszystkich_bajty / 1024 / 1024 / 1024")
suma_wszystkich_TB=$(bc <<< "scale=2; $suma_wszystkich_bajty / 1024 / 1024 / 1024 / 1024")

echo "Suma wielkości dla wszystkich polityk:"
echo "  Bajty: $suma_wszystkich_bajty"
echo "  MB: $suma_wszystkich_MB"
echo "  GB: $suma_wszystkich_GB"
echo "  TB: $suma_wszystkich_TB"




======================================================================================================
<VirtualHost *:80>
    ServerName your-server-name
    DocumentRoot /var/www/html

    # Włącz moduł statusu
    <Location /server-status>
        SetHandler server-status
        Order Deny,Allow
        Deny from all
        Allow from localhost ip6-localhost
        # Użyj SSLRequire do wymuszenia autoryzacji certyfikatem
        SSLRequireSSL
        SSLVerifyClient require
        SSLVerifyDepth  10
    </Location>

    # Włącz eksport metryk w formacie prometheushowym
    <Location /metrics>
        SetHandler prometheus-metrics
        Order Deny,Allow
        Deny from all
        Allow from localhost ip6-localhost
        # Użyj SSLRequire do wymuszenia autoryzacji certyfikatem
        SSLRequireSSL
        SSLVerifyClient require
        SSLVerifyDepth  10
    </Location>

    # Konfiguracja SSL
    SSLEngine on
    SSLCertificateFile "/path/to/your/certificate.pem"
    SSLCertificateKeyFile "/path/to/your/private/key.pem"
    SSLCACertificateFile "/path/to/your/ca_certificate.pem"
</VirtualHost>




Oto przykładowa konfiguracja Apache, która spełnia Twoje wymagania:

```apache
<VirtualHost *:80>
    ServerName your-server-name
    DocumentRoot /var/www/html

    # Włącz moduł statusu
    <Location /server-status>
        SetHandler server-status
        Order Deny,Allow
        Deny from all
        Allow from localhost ip6-localhost
        # Użyj SSLRequire do wymuszenia autoryzacji certyfikatem
        SSLRequireSSL
        SSLVerifyClient require
        SSLVerifyDepth  10
    </Location>

    # Włącz eksport metryk w formacie prometheushowym
    <Location /metrics>
        SetHandler prometheus-metrics
        Order Deny,Allow
        Deny from all
        Allow from localhost ip6-localhost
        # Użyj SSLRequire do wymuszenia autoryzacji certyfikatem
        SSLRequireSSL
        SSLVerifyClient require
        SSLVerifyDepth  10
    </Location>

    # Konfiguracja SSL
    SSLEngine on
    SSLCertificateFile "/path/to/your/certificate.pem"
    SSLCertificateKeyFile "/path/to/your/private/key.pem"
    SSLCACertificateFile "/path/to/your/ca_certificate.pem"
</VirtualHost>
```

Pamiętaj, że powyższa konfiguracja jest tylko przykładem i może wymagać dostosowania do Twojego konkretnego środowiska 
i wymagań. Upewnij się, że ścieżki do plików certyfikatów są poprawne i że masz odpowiednie uprawnienia do ich odczytu.
Ponadto, upewnij się, że masz zainstalowany i włączony moduł `mod_status` dla Apache, który jest wymagany do udostępniania
metryk serwera. Dla metryk w formacie prometheushowym, będziesz potrzebować dodatkowego modułu jak `mod_prometheus`. 

Zawsze zaleca się testowanie wszelkich zmian konfiguracji w środowisku testowym przed ich wdrożeniem na produkcję.



-----------------------

#!/bin/bash

# Deklaracja tablicy asocjacyjnej
declare -A moja_tablica

# Dodawanie wartości do tablicy
moja_tablica["klucz1"]="wartosc1"
moja_tablica["klucze12"]="wartosci12"
moja_tablica["toKlucz"]="ToWartosc"
moja_tablica["tata"]="rata"

# Wyświetlanie wartości dla danego klucza
for klucz in "${!moja_tablica[@]}"; do
    wartosc="${moja_tablica[$klucz]}"
    echo "Klucz: $klucz, Wartość: $wartosc"
done
##############################################################################################3
Oto zmodyfikowane przykłady dla NGINX i jobów Prometheus, które uwzględniają podane przez Ciebie dane:

**Konfiguracja NGINX:**

```bash
http {
    upstream backend {
        server 192.168.100.101;
        server 192.168.100.102;
    }

    server {
        listen 9091;
        server_name app1;

        location / {
            proxy_pass http://192.168.100.201/metric;
            auth_basic "Restricted Content";
            auth_basic_user_file /etc/nginx/.htpasswd_app1;
        }
    }

    server {
        listen 9092;
        server_name app2;

        location / {
            proxy_pass http://192.168.100.202/metric;
            auth_basic "Restricted Content";
            auth_basic_user_file /etc/nginx/.htpasswd_app2;
        }
    }
}
```

**Konfiguracja jobów Prometheus:**

```yaml
scrape_configs:
  - job_name: 'app1'
    scrape_interval: 5s
    static_configs:
      - targets: ['192.168.100.201:9091']
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
        replacement: app1
    basic_auth:
      username: 'user1'
      password: 'password1'

  - job_name: 'app2'
    scrape_interval: 5s
    static_configs:
      - targets: ['192.168.100.202:9092']
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
        replacement: app2
    basic_auth:
      username: 'user2'
      password: 'password2'
```

W powyższych przykładach, `192.168.100.201:9091` i `192.168.100.202:9092` to adresy, z których Prometheus będzie zbierał metryki. Są one mapowane na `app1` i `app2` odpowiednio za pomocą `relabel_configs`. Autentykacja jest obsługiwana przez `basic_auth`, gdzie `username` i `password` to dane uwierzytelniające dla każdego joba.

Pamiętaj, że powyższa konfiguracja jest tylko przykładem i może wymagać dostosowania do twojego konkretnego środowiska i wymagań.
-----------------------------
scrape_configs:
  - job_name: 'app1'
    scrape_interval: 5s
    static_configs:
      - targets: ['localhost:9091']
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
        replacement: app1
    basic_auth:
      username: 'user1'
      password: 'password1'

  - job_name: 'app2'
    scrape_interval: 5s
    static_configs:
      - targets: ['localhost:9092']
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
        replacement: app2
    basic_auth:
      username: 'user2'
      password: 'password2'




Aby skonfigurować osobne organizacje dla `app1` i `app2` w Grafana, musisz najpierw utworzyć organizacje, a następnie dodać do nich odpowiednie źródła danych. Poniżej znajduje się przykładowy proces:

1. **Utwórz organizacje**: Zaloguj się do Grafana jako administrator i przejdź do `Configuration > Server Admin > Organizations`. Kliknij `New Organization` i wprowadź nazwę organizacji (np. `app1` i `app2`).

2. **Dodaj źródła danych**: Przejdź do `Configuration > Data Sources` i kliknij `Add data source`. Wybierz `Prometheus` jako typ źródła danych i wprowadź odpowiednie szczegóły, takie jak adres URL serwera Prometheus.

Poniżej znajduje się przykładowa konfiguracja źródła danych dla `app1`:

```yaml
name: Prometheus-app1
type: prometheus
access: proxy
url: http://192.168.100.101:9091
basicAuth: true
basicAuthUser: user1
basicAuthPassword: password1
```

Podobnie, dla `app2`:

```yaml
name: Prometheus-app2
type: prometheus
access: proxy
url: http://192.168.100.102:9092
basicAuth: true
basicAuthUser: user2
basicAuthPassword: password2
```

Pamiętaj, że powyższa konfiguracja jest tylko przykładem i może wymagać dostosowania do twojego konkretnego środowiska i wymagań. Zawsze należy przestrzegać najlepszych praktyk bezpieczeństwa podczas konfigurowania autentykacji i upewnić się, że wszystkie hasła i dane uwierzytelniające są odpowiednio zabezpieczone.





--------------------------------------
http {
    server {
        listen 9091;
        server_name app1;

        location / {
            proxy_pass http://localhost:9091;
            auth_basic "Restricted Content";
            auth_basic_user_file /etc/nginx/.htpasswd_app1;
        }
    }

    server {
        listen 9092;
        server_name app2;

        location / {
            proxy_pass http://localhost:9092;
            auth_basic "Restricted Content";
            auth_basic_user_file /etc/nginx/.htpasswd_app2;
        }
    }
}

-------------------------------------------------------
https://www.elastic.co/guide/en/elasticsearch/reference/8.8/logging.html
-------------------------------------------------------
/var/log/elasticsearch/crlo-*audit*json.gz {
    daily
    missingok
    nocompress
    notifempty
    create 640 root adm
    postrotate
        find /var/log/elasticsearch/ -name "crlo-*audit*json.gz" -mtime +3 -delete
    endscript
}


------------
curl -X GET "http://localhost:5601/api/saved_objects/_find?type=index-pattern&space_id=nazwa_space" -H 'kbn-xsrf: true'

-----------------------------
Aby dodać nowy indeks do `indices names` dla danej roli w Elasticsearch, możesz najpierw pobrać aktualną listę indeksów, a następnie dodać nowy indeks do tej listy i zaktualizować rolę za pomocą polecenia `curl`. Poniżej znajduje się przykładowy skrypt bash, który wykonuje te zadania:

```bash
# Wykonaj polecenie curl i zapisz wynik do zmiennej
rola="twoja_rola"
wynik=$(curl -X GET "localhost:9200/_security/role/$rola")

# Użyj jq, aby przetworzyć wynik i uzyskać dostęp do indices names
indices_names=$(echo "$wynik" | jq -r ".[\"$rola\"].indices")

# Dodaj nowy indeks do listy
nowy_indeks="twoj_nowy_indeks"
zmienione_indices_names=$(echo "$indices_names" | jq ". += [\"$nowy_indeks\"]")

# Zaktualizuj rolę za pomocą zmienionej listy indeksów
zmieniona_rola=$(echo "$wynik" | jq ".[\"$rola\"].indices = $zmienione_indices_names")
curl -X PUT "localhost:9200/_security/role/$rola" -H 'Content-Type: application/json' -d"$zmieniona_rola"
```

W tym skrypcie, `. += [\"$nowy_indeks\"]` to wyrażenie `jq`, które dodaje nowy indeks do listy indeksów. Następnie `.indices = $zmienione_indices_names` aktualizuje listę indeksów dla danej roli.

Pamiętaj, że musisz zastąpić `"localhost:9200"`, `"twoja_rola"` i `"twoj_nowy_indeks"` odpowiednimi wartościami. Jeśli Twój klaster Elasticsearch jest zabezpieczony, musisz również dostarczyć odpowiednie dane uwierzytelniające z żądaniem `curl`.

Mam nadzieję, że to pomoże! Jeśli masz jakiekolwiek pytania lub potrzebujesz dalszej pomocy, daj mi znać! 😊
--------------------------------------------------------------
# Wykonaj polecenie curl i zapisz wynik do zmiennej
wynik=$(curl -X GET "localhost:9200/_security/role" | jq -r 'keys | .[]')

# Użyj pętli while do odczytywania wyników linia po linii
echo "$wynik" | while read -r rola
do
   echo "$rola"
done

----------------------------------------------------
# Wykonaj polecenie curl i zapisz wynik do zmiennej
wynik=$(curl -X GET "localhost:9200/_security/role" | jq -r 'keys[]')

# Użyj IFS (Internal Field Separator) do podziału wyniku na tablicę
IFS=$'\n' read -r -a tablica <<< "$wynik"

# Wyświetl każdy element tablicy
for rola in "${tablica[@]}"
do
   echo "$rola"
done


------------------------------------
# Wykonaj polecenie curl i zapisz wynik do zmiennej
wynik=$(curl -s 'http://twojastrona.com')

# Użyj IFS (Internal Field Separator) do podziału wyniku na tablicę
IFS=' ' read -r -a tablica <<< "$wynik"

# Wyświetl każdy element tablicy
for element in "${tablica[@]}"
do
   echo "$element"
done

-------------

while read -r line; do
    indices=$(echo $line | grep -oP '(?<="indices":{").*?(?=")')
    storage_size=$(echo $line | grep -oP '(?<=storage.size: ).*?(?= )')
    pri_storage_size=$(echo $line | grep -oP '(?<=pri.storage.size: ).*')
    echo "Indices: $indices"
    echo "Storage size: $storage_size"
    echo "Primary storage size: $pri_storage_size"
done < input.txt
-----------------
script:
  - if [[ $fileList == *"plik1"* ]]; then
      ls -la;
    elif [[ $fileList == *"plik2"* ]]; then
      ls -ltr;
    fi

----------------------------------------
- name: Utwórz katalog jeśli nie istnieje
      file:
        path: /ścieżka/do/katalogu
        state: directory
-------------------------------
- name: Zarchiwizuj istniejące pliki
      copy:
        src: "/lokalizacja/sprawdz/{{ item.item }}"
        dest: "/backup/{{ item.item }}.bak"
        remote_src: yes
      when: item.stat.exists
      loop: "{{ files_stat.results }}"

    - name: Skopiuj nowe pliki do katalogu /lokalizacja/sprawdz
      copy:
        src: "/example/folder/{{ item }}"
        dest: "/lokalizacja/sprawdz/{{ item }}"
      loop: "{{ files_list }}"
---------------------------------------
- FILES=$(echo '['$(ls -1 /example/folder | sed 's/^/"/;s/$/"/' | paste -sd, -)']')
--------------------
dc1_array = [["c7.cluster.pl", "c8.cluster.pl"]]
dc2_array = [["d7.cluster.pl"]]

def check_element(element):
    # Spłaszczanie list wewnętrznych
    dc1_flat = [item for sublist in dc1_array for item in sublist]
    dc2_flat = [item for sublist in dc2_array for item in sublist]

    if element in dc1_flat:
        print(f"{element} znajduje się w dc1_array")
    elif element in dc2_flat:
        print(f"{element} znajduje się w dc2_array")
    else:
        print(f"{element} nie znajduje się ani w dc1_array, ani w dc2_array")

# Przykładowe użycie funkcji
check_element("c7.cluster.pl")
check_element("d7.cluster.pl")
check_element("c9.cluster.pl")

------------------------
CLUSTER_ARRAY = [["c7.cluster.pl", "c8.cluster.pl"], ["d7.cluster.pl"]]
dc1_array = [["c7.cluster.pl", "c8.cluster.pl"]]
dc2_array = [["d7.cluster.pl"]]

# Spłaszczanie list wewnętrznych
dc1_flat = [item for sublist in dc1_array for item in sublist]
dc2_flat = [item for sublist in dc2_array for item in sublist]

# Iteracja po liście list
for cluster in CLUSTER_ARRAY:
    for server in cluster:
        if server in dc1_flat:
            print(f"{server} znajduje się w dc1_array")
        elif server in dc2_flat:
            print(f"{server} znajduje się w dc2_array")
        else:
            print(f"{server} nie znajduje się ani w dc1_array, ani w dc2_array")

------------------------------------------------------------------------------
job1:
  variables:
    CLUSTER_LIST: '[["c7.cluster.pl", "c8.cluster.pl"], ["d7.cluster.pl"]]'
  script:
    - python3 my_script.py


import os
import json

cluster_list = json.loads(os.environ['CLUSTER_LIST'])

for cluster in cluster_list:
    for server in cluster:
        print(server)

--------------------------------------------------------------------
ifArray = [[["pole", "-eq", "wartość", "and"],
            ["pole", "-eq", "wartość", "and"],
            ["pole", "-eq", "wartość"]],
           [["pole", "-eq", "wartość", "and"],
            ["pole", "-eq", "wartość"]],
           [["pole", "-eq", "wartość"]]]

for i in range(len(ifArray)):
    for j in range(len(ifArray[i])):
        for k in range(len(ifArray[i][j])):
            print(f"ifArray[{i}][{j}][{k}] = {ifArray[i][j][k]}")
------------------------
declare -A my_array
my_array=(["key1:subkey1"]="value1" ["key1:subkey2"]="value2" ["key2:subkey1"]="value3")

# Iteracja po kluczach tablicy asocjacyjnej za pomocą pętli for
for key in "${!my_array[@]}"
do
    # Podział klucza na części
    IFS=':' read -ra key_parts <<< "$key"
    # Wypisanie klucza i wartości
    echo "${key_parts[0]}, ${key_parts[1]}: ${my_array[$key]}"
done
-------
#!/bin/bash

declare -A ifArray

ifArray[0,0,0]="pole"
ifArray[0,0,1]="-eq"
ifArray[0,0,2]="wartość"
ifArray[0,0,3]="and"

ifArray[0,1,0]="pole"
ifArray[0,1,1]="-eq"
ifArray[0,1,2]="wartość"
ifArray[0,1,3]="and"

ifArray[0,2,0]="pole"
ifArray[0,2,1]="-eq"
ifArray[0,2,2]="wartość"
ifArray[0,2,3]=""

ifCondition="if [ "
for ((i=0;i<${#ifArray[@]};i++)); do
    for ((j=0;j<${#ifArray[$i]};j++)); do
        ifCondition+="${ifArray[$i,$j,$j]} ${ifArray[$i,$j,$j+1]} ${ifArray[$i,$j,$j+2]}"
        if [[ "${ifArray[$i,$j,$j+3]}" != "" ]]; then
            ifCondition+=" ] ${ifArray[$i,$j,$j+3]} [ "
        fi
    done
done
ifCondition+=" ]; then echo 'Warunek spełniony'; else echo 'Warunek niespełniony'; fi"

eval $ifCondition


-----
declare -A ifArray

ifArray[0,0,0]="pole"
ifArray[0,0,1]="-eq"
ifArray[0,0,2]="wartość"
ifArray[0,0,3]="and"

ifArray[0,1,0]="pole"
ifArray[0,1,1]="-eq"
ifArray[0,1,2]="wartość"
ifArray[0,1,3]="and"

ifArray[0,2,0]="pole"
ifArray[0,2,1]="-eq"
ifArray[0,2,2]="wartość"
ifArray[0,2,3]=""

ifCondition="if [ "
for ((i=0;i<${#ifArray[@]};i++)); do
    ifCondition+="${ifArray[$i,$i,$i]} ${ifArray[$i,$i,$i+1]} ${ifArray[$i,$i,$i+2]}"
    if [[ "${ifArray[$i,$i,$i+3]}" != "" ]]; then
        ifCondition+=" ] ${ifArray[$i,$i,$i+3]} [ "
    fi
done
ifCondition+=" ]; then echo 'Warunek spełniony'; else echo 'Warunek niespełniony'; fi"

eval $ifCondition
---------------
#!/bin/bash

matchingField[0][0]="pole"
condition[0][0]="-eq"
pattern[0][0]="wartość"
rule[0][0]="and"
matchingField[0][1]="pole"
condition[0][1]="-eq"
pattern[0][1]="wartość"
rule[0][1]="and"
matchingField[0][2]="pole"
condition[0][2]="-eq"
pattern[0][2]="wartość"
rule[0][2]=""

matchingField[1][0]="pole"
condition[1][0]="-eq"
pattern[1][0]="wartość"
rule[1][0]="and"
matchingField[1][1]="pole"
condition[1][1]="-eq"
pattern[1][1]="wartość"
rule[1][1]="and"
matchingField[1][2]="pole"
condition[1][2]="-eq"
pattern[1][2]="wartość"
rule[1][2]=""

matchingField[2][0]="pole"
condition[2][0]="-eq"
pattern[2][0]="wartość"
rule[2][0]="and"
matchingField[2][1]="pole"
condition[2][1]="-eq"
pattern[2][1]="wartość"
rule[2][1]=""

matchingField[3][0]="pole"
condition[3][0]="-eq"
pattern[3][0]="wartość"
rule[3][0]=""


ifCondition="if [ "
for ((i=0;i<${#matchingField[@]};i++)); do
    for ((j=0;j<${#matchingField[$i]};j++)); do
        ifCondition+="${matchingField[$i][$j]} ${condition[$i][$j]} ${pattern[$i][$j]}"
        if [[ "${rule[$i][$j]}" != "" ]]; then
            ifCondition+=" ] ${rule[$i][$j]} [ "
        fi
    done
    if [[ $i -lt $((${#matchingField[@]} - 1)) ]]; then
        ifCondition+=" ] || [ "
    fi
done
ifCondition+=" ]; then echo 'Warunek spełniony'; else echo 'Warunek niespełniony'; fi"

eval $ifCondition
--------------------------------------
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "field1": "value1"
          }
        },
        {
          "match": {
            "field2": {
              "query": "value2",
              "fuzziness": "AUTO"
            }
          }
        }
      ]
    }
  }
}

---------------------
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "field1": "value1"
          }
        },
        {
          "wildcard": {
            "field2": "*value2*"
          }
        }
      ]
    }
  }
}

---------------------------------------------------------------
GET /_search
{
  "query": {
    "bool": {
      "must": [
        {
          "wildcard": {
            "field1": "*value1*"
          }
        },
        {
          "wildcard": {
            "field2": "*value2*"
          }
        }
      ]
    }
  }
}
----------------------
GET /_search
{
  "query": {
    "bool": {
      "must": [
        {
          "wildcard": {
            "field1": "*value1*"
          }
        },
        {
          "wildcard": {
            "field2": "*value2*"
          }
        }
      ]
    }
  }
}



####################################################################33
#!/bin/bash

file1="file1.txt"
file2="file2.txt"

echo "Linie z $file1, które nie mają dopasowania w $file2:"
while read -r line1; do
  match=0
  while read -r line2; do
    if [[ "$line1" == "$line2" ]]; then
      match=1
      break
    fi
  done < "$file2"
  if [[ $match -eq 0 ]]; then
    echo "$line1"
  fi
done < "$file1"

echo "Linie z $file2, które nie mają dopasowania w $file1:"
while read -r line2; do
  match=0
  while read -r line1; do
    if [[ "$line2" == "$line1" ]]; then
      match=1
      break
    fi
  done < "$file1"
  if [[ $match -eq 0 ]]; then
    echo "$line2"
  fi
done < "$file2"
