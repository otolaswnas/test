#!/bin/bash

# Ustawienie wartoci dla zmiennej tablicowej suma_polityki
polityka="test-ilm"
fabryka_wielkosc="123"
suma_polityki["$polityka"]["wielko"]=$fabryka_wielkosc

# Wypisanie wartoci zmiennej tablicowej suma_polityki
echo "Warto suma_polityki[$polityka][wielko]: ${suma_polityki[$polityka][wielko]}"




#!/bin/bash

# Ustawienie wartoci dla zmiennej tablicowej suma_polityki
polityka="test-ilm"
fabryka_wielkosc="123"
suma_polityki["$polityka"]["wielko"]=$fabryka_wielkosc

# Wypisanie wartoci zmiennej tablicowej suma_polityki
echo "Warto suma_polityki[$polityka][wielko]: ${suma_polityki[$polityka][wielko]}"




#!/bin/bash

# Przypisanie wartoci dla zmiennych
polityka="test-ilm"
fabryka_wielkosc="123"

# Utworzenie tablicy suma_polityki i przypisanie wartoci
declare -A suma_polityki
suma_polityki["$polityka"]=""
suma_polityki["$polityka"]["wielko"]="$fabryka_wielkosc"

# Wywietlenie wartoci dla klucza $polityka i klucza wielko
echo "${suma_polityki[$polityka][wielko]}"



#!/bin/bash

# Ustawienie wartoci dla zmiennej tablicowej
polityka="test-ilm"
fabryka_wielkosc="123"
suma_polityki["$polityka"]["wielko"]=$fabryka_wielkosc

# Wypisanie wartoci zmiennej
echo "Warto zmiennej suma_polityki: ${suma_polityki[$polityka][wielko]}"



# Wywietlenie wynik贸w jako JSON i zapis do pliku
for polityka in "${!wyniki_json[@]}"; do
    echo "\"$polityka\": ${wyniki_json["$polityka"]}"
done | jq -s . > wyniki.json
------------------
suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")

    suma_bajty_z_replika=${suma_polityk_z_replika["$polityka"]}
    suma_MB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024")
    suma_GB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024")
    suma_TB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024 / 1024")

    wyniki_json["$polityka"]='{"bez_repliki":{"Bajty":'$suma_bajty',"MB":'$suma_MB',"GB":'$suma_GB',"TB":'$suma_TB'},"z_replika":{"Bajty":'$suma_bajty_z_replika',"MB":'$suma_MB_z_replika',"GB":'$suma_GB_z_replika',"TB":'$suma_TB_z_replika'}}'

--------------------
#!/bin/bash
# Tworzymy asocjacyjny sownik, w kt贸rym kluczem jest nazwa polityki, a wartoci suma wielkoci w bajtach
declare -A suma_polityk
# Przetwarzamy dane linia po linii
while read -r line; do
    # Sprawdzamy, czy linia nie jest pusta
    if [[ -n "$line" ]]; then
        index=$(echo "$line" | jq -r '.indexname')
        polityka=$(echo "$line" | jq -r '.ilmname')
        wielkosc_index=$(echo "$line" | jq -r '.sizeindex')
        wielkosc_index_z_replika=$(echo "$line" | jq -r '.sizeindexwithreplica')

        # Dodajemy wielkoci do sumy dla danej polityki
        suma_polityk["$polityka"]=$((suma_polityk["$polityka"] + wielkosc_index))
        suma_polityk_z_replika["$polityka"]=$((suma_polityk_z_replika["$polityka"] + wielkosc_index_z_replika))
    fi
done < plik_z_danymi.txt
for polityka in "${!suma_polityk[@]}"; do
    suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")
    echo "Suma wielkoci dla polityki $polityka (bez repliki):"
    echo "  Bajty: $suma_bajty"
    echo "  MB: $suma_MB"
    echo "  GB: $suma_GB"
    echo "  TB: $suma_TB"
    suma_bajty_z_replika=${suma_polityk_z_replika["$polityka"]}
    suma_MB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024")
    suma_GB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024")
    suma_TB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024 / 1024")
    echo "Suma wielkoci dla polityki $polityka (z replik):"
    echo "  Bajty: $suma_bajty_z_replika"
    echo "  MB: $suma_MB_z_replika"
    echo "  GB: $suma_GB_z_replika"
    echo "  TB: $suma_TB_z_replika"
done


----------------------------------------------------------
#!/bin/bash
# Tworzymy asocjacyjny sownik, w kt贸rym kluczem jest nazwa polityki, a wartoci suma wielkoci w bajtach
declare -A suma_polityk
declare -A suma_polityk_z_replika

# Przetwarzamy dane linia po linii
while read -r line; do
    # Sprawdzamy, czy linia nie jest pusta
    if [[ -n "$line" ]]; then
        # Wycigamy wartoci index, polityka, wielko index oraz wielko index z replik
        index=$(echo "$line" | jq -r '.indexname')
        polityka=$(echo "$line" | jq -r '.ilmname')
        wielkosc_index=$(echo "$line" | jq -r '.sizeindex')
        wielkosc_index_z_replika=$(echo "$line" | jq -r '.sizeindexwithreplica')

        # Dodajemy wielkoci do sumy dla danej polityki
        suma_polityk["$polityka"]=$(bc <<< "${suma_polityk["$polityka"]} + $wielkosc_index")
        suma_polityk_z_replika["$polityka"]=$(bc <<< "${suma_polityk_z_replika["$polityka"]} + $wielkosc_index_z_replika")
    fi
done < plik_z_danymi.txt

# Wywietlamy wyniki w r贸偶nych jednostkach
for polityka in "${!suma_polityk[@]}"; do
    suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielkoci dla polityki $polityka (bez repliki):"
    echo "  Bajty: $suma_bajty"
    echo "  MB: $suma_MB"
    echo "  GB: $suma_GB"
    echo "  TB: $suma_TB"

    suma_bajty_z_replika=${suma_polityk_z_replika["$polityka"]}
    suma_MB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024")
    suma_GB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024")
    suma_TB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielkoci dla polityki $polityka (z replik):"
    echo "  Bajty: $suma_bajty_z_replika"
    echo "  MB: $suma_MB_z_replika"
    echo "  GB: $suma_GB_z_replika"
    echo "  TB: $suma_TB_z_replika"
done



-------------------------------------------
#!/bin/bash
# Tworzymy asocjacyjny sownik, w kt贸rym kluczem jest nazwa polityki, a wartoci suma wielkoci w bajtach
declare -A suma_polityk
declare -A suma_polityk_z_replika

# Przetwarzamy dane linia po linii
while read -r line; do
    # Sprawdzamy, czy linia nie jest pusta
    if [[ -n "$line" ]]; then
        # Wycigamy wartoci index, polityka, wielko index oraz wielko index z replik
        index=$(echo "$line" | jq -r '.indexname')
        polityka=$(echo "$line" | jq -r '.ilmname')
        wielkosc_index=$(echo "$line" | jq -r '.sizeindex')
        wielkosc_index_z_replika=$(echo "$line" | jq -r '.sizeindexwithreplica')

        # Dodajemy wielkoci do sumy dla danej polityki
        suma_polityk["$polityka"]=$(bc <<< "${suma_polityk["$polityka"]} + $wielkosc_index")
        suma_polityk_z_replika["$polityka"]=$(bc <<< "${suma_polityk_z_replika["$polityka"]} + $wielkosc_index_z_replika")
    fi
done < plik_z_danymi.txt

# Wywietlamy wyniki w r贸偶nych jednostkach
for polityka in "${!suma_polityk[@]}"; do
    suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielkoci dla polityki $polityka (bez repliki):"
    echo "  Bajty: $suma_bajty"
    echo "  MB: $suma_MB"
    echo "  GB: $suma_GB"
    echo "  TB: $suma_TB"

    suma_bajty_z_replika=${suma_polityk_z_replika["$polityka"]}
    suma_MB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024")
    suma_GB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024")
    suma_TB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielkoci dla polityki $polityka (z replik):"
    echo "  Bajty: $suma_bajty_z_replika"
    echo "  MB: $suma_MB_z_replika"
    echo "  GB: $suma_GB_z_replika"
    echo "  TB: $suma_TB_z_replika"
done

------------------------------------------------------------------------------------
#!/bin/bash
# Tworzymy asocjacyjny sownik, w kt贸rym kluczem jest nazwa polityki, a wartoci suma wielkoci w bajtach
declare -A suma_polityk

# Przetwarzamy dane linia po linii
while read -r line; do
    # Sprawdzamy, czy linia nie jest pusta
    if [[ -n "$line" ]]; then
        # Wycigamy wartoci index, polityka, wielko index oraz wielko index z replik
        index=$(echo "$line" | jq -r '.indexname')
        polityka=$(echo "$line" | jq -r '.ilmname')
        wielkosc_index=$(echo "$line" | jq -r '.sizeindex')
        wielkosc_index_z_replika=$(echo "$line" | jq -r '.sizeindexwithreplica')

        # Dodajemy wielkoci do sumy dla danej polityki
        suma_polityk["$polityka"]=$((suma_polityk["$polityka"] + wielkosc_index))
        suma_polityk_z_replika["$polityka"]=$((suma_polityk_z_replika["$polityka"] + wielkosc_index_z_replika))
    fi
done < plik_z_danymi.txt

# Wywietlamy wyniki w r贸偶nych jednostkach
for polityka in "${!suma_polityk[@]}"; do
    suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielkoci dla polityki $polityka (bez repliki):"
    echo "  Bajty: $suma_bajty"
    echo "  MB: $suma_MB"
    echo "  GB: $suma_GB"
    echo "  TB: $suma_TB"

    suma_bajty_z_replika=${suma_polityk_z_replika["$polityka"]}
    suma_MB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024")
    suma_GB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024")
    suma_TB_z_replika=$(bc <<< "scale=2; $suma_bajty_z_replika / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielkoci dla polityki $polityka (z replik):"
    echo "  Bajty: $suma_bajty_z_replika"
    echo "  MB: $suma_MB_z_replika"
    echo "  GB: $suma_GB_z_replika"
    echo "  TB: $suma_TB_z_replika"
done

-------------------------------------------------------------------------------------
#!/bin/bash

# Tworzymy asocjacyjny sownik, w kt贸rym kluczem jest nazwa polityki, a wartoci suma wielkoci w bajtach
declare -A suma_polityk

# Przetwarzamy dane linia po linii
while read -r line; do
    # Sprawdzamy, czy linia nie jest pusta
    if [[ -n "$line" ]]; then
        # Wycigamy wartoci index, polityka, wielko index oraz wielko index z replik
        index=$(echo "$line" | jq -r '.indexname')
        polityka=$(echo "$line" | jq -r '.ilmname')
        wielkosc_index=$(echo "$line" | jq -r '.sizeindex')
        wielkosc_index_z_replika=$(echo "$line" | jq -r '.sizeindexwithreplica')

        # Dodajemy wielkoci do sumy dla danej polityki
        suma_polityk["$polityka"]=$((suma_polityk["$polityka"] + wielkosc_index + wielkosc_index_z_replika))
    fi
done < plik_z_danymi.txt

# Wywietlamy wyniki w r贸偶nych jednostkach
for polityka in "${!suma_polityk[@]}"; do
    suma_bajty=${suma_polityk["$polityka"]}
    suma_MB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024")
    suma_GB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024")
    suma_TB=$(bc <<< "scale=2; $suma_bajty / 1024 / 1024 / 1024 / 1024")

    echo "Suma wielkoci dla polityki $polityka:"
    echo "  Bajty: $suma_bajty"
    echo "  MB: $suma_MB"
    echo "  GB: $suma_GB"
    echo "  TB: $suma_TB"
done

# Obliczamy sum wszystkich polityk w r贸偶nych jednostkach
suma_wszystkich_bajty=$(echo "${suma_polityk[@]}" | tr ' ' '+' | bc)
suma_wszystkich_MB=$(bc <<< "scale=2; $suma_wszystkich_bajty / 1024 / 1024")
suma_wszystkich_GB=$(bc <<< "scale=2; $suma_wszystkich_bajty / 1024 / 1024 / 1024")
suma_wszystkich_TB=$(bc <<< "scale=2; $suma_wszystkich_bajty / 1024 / 1024 / 1024 / 1024")

echo "Suma wielkoci dla wszystkich polityk:"
echo "  Bajty: $suma_wszystkich_bajty"
echo "  MB: $suma_wszystkich_MB"
echo "  GB: $suma_wszystkich_GB"
echo "  TB: $suma_wszystkich_TB"




======================================================================================================
<VirtualHost *:80>
    ServerName your-server-name
    DocumentRoot /var/www/html

    # Wcz modu statusu
    <Location /server-status>
        SetHandler server-status
        Order Deny,Allow
        Deny from all
        Allow from localhost ip6-localhost
        # U偶yj SSLRequire do wymuszenia autoryzacji certyfikatem
        SSLRequireSSL
        SSLVerifyClient require
        SSLVerifyDepth  10
    </Location>

    # Wcz eksport metryk w formacie prometheushowym
    <Location /metrics>
        SetHandler prometheus-metrics
        Order Deny,Allow
        Deny from all
        Allow from localhost ip6-localhost
        # U偶yj SSLRequire do wymuszenia autoryzacji certyfikatem
        SSLRequireSSL
        SSLVerifyClient require
        SSLVerifyDepth  10
    </Location>

    # Konfiguracja SSL
    SSLEngine on
    SSLCertificateFile "/path/to/your/certificate.pem"
    SSLCertificateKeyFile "/path/to/your/private/key.pem"
    SSLCACertificateFile "/path/to/your/ca_certificate.pem"
</VirtualHost>




Oto przykadowa konfiguracja Apache, kt贸ra spenia Twoje wymagania:

```apache
<VirtualHost *:80>
    ServerName your-server-name
    DocumentRoot /var/www/html

    # Wcz modu statusu
    <Location /server-status>
        SetHandler server-status
        Order Deny,Allow
        Deny from all
        Allow from localhost ip6-localhost
        # U偶yj SSLRequire do wymuszenia autoryzacji certyfikatem
        SSLRequireSSL
        SSLVerifyClient require
        SSLVerifyDepth  10
    </Location>

    # Wcz eksport metryk w formacie prometheushowym
    <Location /metrics>
        SetHandler prometheus-metrics
        Order Deny,Allow
        Deny from all
        Allow from localhost ip6-localhost
        # U偶yj SSLRequire do wymuszenia autoryzacji certyfikatem
        SSLRequireSSL
        SSLVerifyClient require
        SSLVerifyDepth  10
    </Location>

    # Konfiguracja SSL
    SSLEngine on
    SSLCertificateFile "/path/to/your/certificate.pem"
    SSLCertificateKeyFile "/path/to/your/private/key.pem"
    SSLCACertificateFile "/path/to/your/ca_certificate.pem"
</VirtualHost>
```

Pamitaj, 偶e powy偶sza konfiguracja jest tylko przykadem i mo偶e wymaga dostosowania do Twojego konkretnego rodowiska 
i wymaga. Upewnij si, 偶e cie偶ki do plik贸w certyfikat贸w s poprawne i 偶e masz odpowiednie uprawnienia do ich odczytu.
Ponadto, upewnij si, 偶e masz zainstalowany i wczony modu `mod_status` dla Apache, kt贸ry jest wymagany do udostpniania
metryk serwera. Dla metryk w formacie prometheushowym, bdziesz potrzebowa dodatkowego moduu jak `mod_prometheus`. 

Zawsze zaleca si testowanie wszelkich zmian konfiguracji w rodowisku testowym przed ich wdro偶eniem na produkcj.



-----------------------

#!/bin/bash

# Deklaracja tablicy asocjacyjnej
declare -A moja_tablica

# Dodawanie wartoci do tablicy
moja_tablica["klucz1"]="wartosc1"
moja_tablica["klucze12"]="wartosci12"
moja_tablica["toKlucz"]="ToWartosc"
moja_tablica["tata"]="rata"

# Wywietlanie wartoci dla danego klucza
for klucz in "${!moja_tablica[@]}"; do
    wartosc="${moja_tablica[$klucz]}"
    echo "Klucz: $klucz, Warto: $wartosc"
done
##############################################################################################3
Oto zmodyfikowane przykady dla NGINX i job贸w Prometheus, kt贸re uwzgldniaj podane przez Ciebie dane:

**Konfiguracja NGINX:**

```bash
http {
    upstream backend {
        server 192.168.100.101;
        server 192.168.100.102;
    }

    server {
        listen 9091;
        server_name app1;

        location / {
            proxy_pass http://192.168.100.201/metric;
            auth_basic "Restricted Content";
            auth_basic_user_file /etc/nginx/.htpasswd_app1;
        }
    }

    server {
        listen 9092;
        server_name app2;

        location / {
            proxy_pass http://192.168.100.202/metric;
            auth_basic "Restricted Content";
            auth_basic_user_file /etc/nginx/.htpasswd_app2;
        }
    }
}
```

**Konfiguracja job贸w Prometheus:**

```yaml
scrape_configs:
  - job_name: 'app1'
    scrape_interval: 5s
    static_configs:
      - targets: ['192.168.100.201:9091']
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
        replacement: app1
    basic_auth:
      username: 'user1'
      password: 'password1'

  - job_name: 'app2'
    scrape_interval: 5s
    static_configs:
      - targets: ['192.168.100.202:9092']
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
        replacement: app2
    basic_auth:
      username: 'user2'
      password: 'password2'
```

W powy偶szych przykadach, `192.168.100.201:9091` i `192.168.100.202:9092` to adresy, z kt贸rych Prometheus bdzie zbiera metryki. S one mapowane na `app1` i `app2` odpowiednio za pomoc `relabel_configs`. Autentykacja jest obsugiwana przez `basic_auth`, gdzie `username` i `password` to dane uwierzytelniajce dla ka偶dego joba.

Pamitaj, 偶e powy偶sza konfiguracja jest tylko przykadem i mo偶e wymaga dostosowania do twojego konkretnego rodowiska i wymaga.
-----------------------------
scrape_configs:
  - job_name: 'app1'
    scrape_interval: 5s
    static_configs:
      - targets: ['localhost:9091']
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
        replacement: app1
    basic_auth:
      username: 'user1'
      password: 'password1'

  - job_name: 'app2'
    scrape_interval: 5s
    static_configs:
      - targets: ['localhost:9092']
    relabel_configs:
      - source_labels: [__address__]
        target_label: instance
        replacement: app2
    basic_auth:
      username: 'user2'
      password: 'password2'




Aby skonfigurowa osobne organizacje dla `app1` i `app2` w Grafana, musisz najpierw utworzy organizacje, a nastpnie doda do nich odpowiednie 藕r贸da danych. Poni偶ej znajduje si przykadowy proces:

1. **Utw贸rz organizacje**: Zaloguj si do Grafana jako administrator i przejd藕 do `Configuration > Server Admin > Organizations`. Kliknij `New Organization` i wprowad藕 nazw organizacji (np. `app1` i `app2`).

2. **Dodaj 藕r贸da danych**: Przejd藕 do `Configuration > Data Sources` i kliknij `Add data source`. Wybierz `Prometheus` jako typ 藕r贸da danych i wprowad藕 odpowiednie szczeg贸y, takie jak adres URL serwera Prometheus.

Poni偶ej znajduje si przykadowa konfiguracja 藕r贸da danych dla `app1`:

```yaml
name: Prometheus-app1
type: prometheus
access: proxy
url: http://192.168.100.101:9091
basicAuth: true
basicAuthUser: user1
basicAuthPassword: password1
```

Podobnie, dla `app2`:

```yaml
name: Prometheus-app2
type: prometheus
access: proxy
url: http://192.168.100.102:9092
basicAuth: true
basicAuthUser: user2
basicAuthPassword: password2
```

Pamitaj, 偶e powy偶sza konfiguracja jest tylko przykadem i mo偶e wymaga dostosowania do twojego konkretnego rodowiska i wymaga. Zawsze nale偶y przestrzega najlepszych praktyk bezpieczestwa podczas konfigurowania autentykacji i upewni si, 偶e wszystkie hasa i dane uwierzytelniajce s odpowiednio zabezpieczone.





--------------------------------------
http {
    server {
        listen 9091;
        server_name app1;

        location / {
            proxy_pass http://localhost:9091;
            auth_basic "Restricted Content";
            auth_basic_user_file /etc/nginx/.htpasswd_app1;
        }
    }

    server {
        listen 9092;
        server_name app2;

        location / {
            proxy_pass http://localhost:9092;
            auth_basic "Restricted Content";
            auth_basic_user_file /etc/nginx/.htpasswd_app2;
        }
    }
}

-------------------------------------------------------
https://www.elastic.co/guide/en/elasticsearch/reference/8.8/logging.html
-------------------------------------------------------
/var/log/elasticsearch/crlo-*audit*json.gz {
    daily
    missingok
    nocompress
    notifempty
    create 640 root adm
    postrotate
        find /var/log/elasticsearch/ -name "crlo-*audit*json.gz" -mtime +3 -delete
    endscript
}


------------
curl -X GET "http://localhost:5601/api/saved_objects/_find?type=index-pattern&space_id=nazwa_space" -H 'kbn-xsrf: true'

-----------------------------
Aby doda nowy indeks do `indices names` dla danej roli w Elasticsearch, mo偶esz najpierw pobra aktualn list indeks贸w, a nastpnie doda nowy indeks do tej listy i zaktualizowa rol za pomoc polecenia `curl`. Poni偶ej znajduje si przykadowy skrypt bash, kt贸ry wykonuje te zadania:

```bash
# Wykonaj polecenie curl i zapisz wynik do zmiennej
rola="twoja_rola"
wynik=$(curl -X GET "localhost:9200/_security/role/$rola")

# U偶yj jq, aby przetworzy wynik i uzyska dostp do indices names
indices_names=$(echo "$wynik" | jq -r ".[\"$rola\"].indices")

# Dodaj nowy indeks do listy
nowy_indeks="twoj_nowy_indeks"
zmienione_indices_names=$(echo "$indices_names" | jq ". += [\"$nowy_indeks\"]")

# Zaktualizuj rol za pomoc zmienionej listy indeks贸w
zmieniona_rola=$(echo "$wynik" | jq ".[\"$rola\"].indices = $zmienione_indices_names")
curl -X PUT "localhost:9200/_security/role/$rola" -H 'Content-Type: application/json' -d"$zmieniona_rola"
```

W tym skrypcie, `. += [\"$nowy_indeks\"]` to wyra偶enie `jq`, kt贸re dodaje nowy indeks do listy indeks贸w. Nastpnie `.indices = $zmienione_indices_names` aktualizuje list indeks贸w dla danej roli.

Pamitaj, 偶e musisz zastpi `"localhost:9200"`, `"twoja_rola"` i `"twoj_nowy_indeks"` odpowiednimi wartociami. Jeli Tw贸j klaster Elasticsearch jest zabezpieczony, musisz r贸wnie偶 dostarczy odpowiednie dane uwierzytelniajce z 偶daniem `curl`.

Mam nadziej, 偶e to pomo偶e! Jeli masz jakiekolwiek pytania lub potrzebujesz dalszej pomocy, daj mi zna! 
--------------------------------------------------------------
# Wykonaj polecenie curl i zapisz wynik do zmiennej
wynik=$(curl -X GET "localhost:9200/_security/role" | jq -r 'keys | .[]')

# U偶yj ptli while do odczytywania wynik贸w linia po linii
echo "$wynik" | while read -r rola
do
   echo "$rola"
done

----------------------------------------------------
# Wykonaj polecenie curl i zapisz wynik do zmiennej
wynik=$(curl -X GET "localhost:9200/_security/role" | jq -r 'keys[]')

# U偶yj IFS (Internal Field Separator) do podziau wyniku na tablic
IFS=$'\n' read -r -a tablica <<< "$wynik"

# Wywietl ka偶dy element tablicy
for rola in "${tablica[@]}"
do
   echo "$rola"
done


------------------------------------
# Wykonaj polecenie curl i zapisz wynik do zmiennej
wynik=$(curl -s 'http://twojastrona.com')

# U偶yj IFS (Internal Field Separator) do podziau wyniku na tablic
IFS=' ' read -r -a tablica <<< "$wynik"

# Wywietl ka偶dy element tablicy
for element in "${tablica[@]}"
do
   echo "$element"
done

-------------

while read -r line; do
    indices=$(echo $line | grep -oP '(?<="indices":{").*?(?=")')
    storage_size=$(echo $line | grep -oP '(?<=storage.size: ).*?(?= )')
    pri_storage_size=$(echo $line | grep -oP '(?<=pri.storage.size: ).*')
    echo "Indices: $indices"
    echo "Storage size: $storage_size"
    echo "Primary storage size: $pri_storage_size"
done < input.txt
-----------------
script:
  - if [[ $fileList == *"plik1"* ]]; then
      ls -la;
    elif [[ $fileList == *"plik2"* ]]; then
      ls -ltr;
    fi

----------------------------------------
- name: Utw贸rz katalog jeli nie istnieje
      file:
        path: /cie偶ka/do/katalogu
        state: directory
-------------------------------
- name: Zarchiwizuj istniejce pliki
      copy:
        src: "/lokalizacja/sprawdz/{{ item.item }}"
        dest: "/backup/{{ item.item }}.bak"
        remote_src: yes
      when: item.stat.exists
      loop: "{{ files_stat.results }}"

    - name: Skopiuj nowe pliki do katalogu /lokalizacja/sprawdz
      copy:
        src: "/example/folder/{{ item }}"
        dest: "/lokalizacja/sprawdz/{{ item }}"
      loop: "{{ files_list }}"
---------------------------------------
- FILES=$(echo '['$(ls -1 /example/folder | sed 's/^/"/;s/$/"/' | paste -sd, -)']')
--------------------
dc1_array = [["c7.cluster.pl", "c8.cluster.pl"]]
dc2_array = [["d7.cluster.pl"]]

def check_element(element):
    # Spaszczanie list wewntrznych
    dc1_flat = [item for sublist in dc1_array for item in sublist]
    dc2_flat = [item for sublist in dc2_array for item in sublist]

    if element in dc1_flat:
        print(f"{element} znajduje si w dc1_array")
    elif element in dc2_flat:
        print(f"{element} znajduje si w dc2_array")
    else:
        print(f"{element} nie znajduje si ani w dc1_array, ani w dc2_array")

# Przykadowe u偶ycie funkcji
check_element("c7.cluster.pl")
check_element("d7.cluster.pl")
check_element("c9.cluster.pl")

------------------------
CLUSTER_ARRAY = [["c7.cluster.pl", "c8.cluster.pl"], ["d7.cluster.pl"]]
dc1_array = [["c7.cluster.pl", "c8.cluster.pl"]]
dc2_array = [["d7.cluster.pl"]]

# Spaszczanie list wewntrznych
dc1_flat = [item for sublist in dc1_array for item in sublist]
dc2_flat = [item for sublist in dc2_array for item in sublist]

# Iteracja po licie list
for cluster in CLUSTER_ARRAY:
    for server in cluster:
        if server in dc1_flat:
            print(f"{server} znajduje si w dc1_array")
        elif server in dc2_flat:
            print(f"{server} znajduje si w dc2_array")
        else:
            print(f"{server} nie znajduje si ani w dc1_array, ani w dc2_array")

------------------------------------------------------------------------------
job1:
  variables:
    CLUSTER_LIST: '[["c7.cluster.pl", "c8.cluster.pl"], ["d7.cluster.pl"]]'
  script:
    - python3 my_script.py


import os
import json

cluster_list = json.loads(os.environ['CLUSTER_LIST'])

for cluster in cluster_list:
    for server in cluster:
        print(server)

--------------------------------------------------------------------
ifArray = [[["pole", "-eq", "warto", "and"],
            ["pole", "-eq", "warto", "and"],
            ["pole", "-eq", "warto"]],
           [["pole", "-eq", "warto", "and"],
            ["pole", "-eq", "warto"]],
           [["pole", "-eq", "warto"]]]

for i in range(len(ifArray)):
    for j in range(len(ifArray[i])):
        for k in range(len(ifArray[i][j])):
            print(f"ifArray[{i}][{j}][{k}] = {ifArray[i][j][k]}")
------------------------
declare -A my_array
my_array=(["key1:subkey1"]="value1" ["key1:subkey2"]="value2" ["key2:subkey1"]="value3")

# Iteracja po kluczach tablicy asocjacyjnej za pomoc ptli for
for key in "${!my_array[@]}"
do
    # Podzia klucza na czci
    IFS=':' read -ra key_parts <<< "$key"
    # Wypisanie klucza i wartoci
    echo "${key_parts[0]}, ${key_parts[1]}: ${my_array[$key]}"
done
-------
#!/bin/bash

declare -A ifArray

ifArray[0,0,0]="pole"
ifArray[0,0,1]="-eq"
ifArray[0,0,2]="warto"
ifArray[0,0,3]="and"

ifArray[0,1,0]="pole"
ifArray[0,1,1]="-eq"
ifArray[0,1,2]="warto"
ifArray[0,1,3]="and"

ifArray[0,2,0]="pole"
ifArray[0,2,1]="-eq"
ifArray[0,2,2]="warto"
ifArray[0,2,3]=""

ifCondition="if [ "
for ((i=0;i<${#ifArray[@]};i++)); do
    for ((j=0;j<${#ifArray[$i]};j++)); do
        ifCondition+="${ifArray[$i,$j,$j]} ${ifArray[$i,$j,$j+1]} ${ifArray[$i,$j,$j+2]}"
        if [[ "${ifArray[$i,$j,$j+3]}" != "" ]]; then
            ifCondition+=" ] ${ifArray[$i,$j,$j+3]} [ "
        fi
    done
done
ifCondition+=" ]; then echo 'Warunek speniony'; else echo 'Warunek niespeniony'; fi"

eval $ifCondition


-----
declare -A ifArray

ifArray[0,0,0]="pole"
ifArray[0,0,1]="-eq"
ifArray[0,0,2]="warto"
ifArray[0,0,3]="and"

ifArray[0,1,0]="pole"
ifArray[0,1,1]="-eq"
ifArray[0,1,2]="warto"
ifArray[0,1,3]="and"

ifArray[0,2,0]="pole"
ifArray[0,2,1]="-eq"
ifArray[0,2,2]="warto"
ifArray[0,2,3]=""

ifCondition="if [ "
for ((i=0;i<${#ifArray[@]};i++)); do
    ifCondition+="${ifArray[$i,$i,$i]} ${ifArray[$i,$i,$i+1]} ${ifArray[$i,$i,$i+2]}"
    if [[ "${ifArray[$i,$i,$i+3]}" != "" ]]; then
        ifCondition+=" ] ${ifArray[$i,$i,$i+3]} [ "
    fi
done
ifCondition+=" ]; then echo 'Warunek speniony'; else echo 'Warunek niespeniony'; fi"

eval $ifCondition
---------------
#!/bin/bash

matchingField[0][0]="pole"
condition[0][0]="-eq"
pattern[0][0]="warto"
rule[0][0]="and"
matchingField[0][1]="pole"
condition[0][1]="-eq"
pattern[0][1]="warto"
rule[0][1]="and"
matchingField[0][2]="pole"
condition[0][2]="-eq"
pattern[0][2]="warto"
rule[0][2]=""

matchingField[1][0]="pole"
condition[1][0]="-eq"
pattern[1][0]="warto"
rule[1][0]="and"
matchingField[1][1]="pole"
condition[1][1]="-eq"
pattern[1][1]="warto"
rule[1][1]="and"
matchingField[1][2]="pole"
condition[1][2]="-eq"
pattern[1][2]="warto"
rule[1][2]=""

matchingField[2][0]="pole"
condition[2][0]="-eq"
pattern[2][0]="warto"
rule[2][0]="and"
matchingField[2][1]="pole"
condition[2][1]="-eq"
pattern[2][1]="warto"
rule[2][1]=""

matchingField[3][0]="pole"
condition[3][0]="-eq"
pattern[3][0]="warto"
rule[3][0]=""


ifCondition="if [ "
for ((i=0;i<${#matchingField[@]};i++)); do
    for ((j=0;j<${#matchingField[$i]};j++)); do
        ifCondition+="${matchingField[$i][$j]} ${condition[$i][$j]} ${pattern[$i][$j]}"
        if [[ "${rule[$i][$j]}" != "" ]]; then
            ifCondition+=" ] ${rule[$i][$j]} [ "
        fi
    done
    if [[ $i -lt $((${#matchingField[@]} - 1)) ]]; then
        ifCondition+=" ] || [ "
    fi
done
ifCondition+=" ]; then echo 'Warunek speniony'; else echo 'Warunek niespeniony'; fi"

eval $ifCondition
--------------------------------------
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "field1": "value1"
          }
        },
        {
          "match": {
            "field2": {
              "query": "value2",
              "fuzziness": "AUTO"
            }
          }
        }
      ]
    }
  }
}

---------------------
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "field1": "value1"
          }
        },
        {
          "wildcard": {
            "field2": "*value2*"
          }
        }
      ]
    }
  }
}

---------------------------------------------------------------
GET /_search
{
  "query": {
    "bool": {
      "must": [
        {
          "wildcard": {
            "field1": "*value1*"
          }
        },
        {
          "wildcard": {
            "field2": "*value2*"
          }
        }
      ]
    }
  }
}
----------------------
GET /_search
{
  "query": {
    "bool": {
      "must": [
        {
          "wildcard": {
            "field1": "*value1*"
          }
        },
        {
          "wildcard": {
            "field2": "*value2*"
          }
        }
      ]
    }
  }
}



####################################################################33
#!/bin/bash

file1="file1.txt"
file2="file2.txt"

echo "Linie z $file1, kt贸re nie maj dopasowania w $file2:"
while read -r line1; do
  match=0
  while read -r line2; do
    if [[ "$line1" == "$line2" ]]; then
      match=1
      break
    fi
  done < "$file2"
  if [[ $match -eq 0 ]]; then
    echo "$line1"
  fi
done < "$file1"

echo "Linie z $file2, kt贸re nie maj dopasowania w $file1:"
while read -r line2; do
  match=0
  while read -r line1; do
    if [[ "$line2" == "$line1" ]]; then
      match=1
      break
    fi
  done < "$file1"
  if [[ $match -eq 0 ]]; then
    echo "$line2"
  fi
done < "$file2"
