
#!/usr/bin/env bash
set -Eeuo pipefail

usage() {
  cat <<EOF
UÅ¼ycie: $0 -k <keystore> [-t JKS|PKCS12] [-p <hasÅ‚o>] [-w <dni_ostrzeÅ¼enia>]
PrzykÅ‚ad: $0 -k keystore.jks -t JKS
EOF
}

KS="" ; TYPE="" ; PASS="" ; WARN_DAYS=30
while [[ $# -gt 0 ]]; do
  case "$1" in
    -k|--keystore) KS="$2"; shift 2;;
    -t|--type)     TYPE="$2"; shift 2;;
    -p|--password) PASS="$2"; shift 2;;
    -w|--warn)     WARN_DAYS="$2"; shift 2;;
    -h|--help)     usage; exit 0;;
    *) echo "Nieznany parametr: $1" >&2; usage; exit 1;;
  esac
done

[[ -z "$KS" ]] && { echo "Podaj -k <keystore>" >&2; usage; exit 1; }
command -v keytool >/dev/null || { echo "Brak keytool w PATH" >&2; exit 1; }
if ! command -v openssl >/dev/null; then
  echo "Uwaga: brak openssl â€“ czÄ™Å›Ä‡ pÃ³l bÄ™dzie ograniczona." >&2
fi

# DomyÅ›l rozpoznanie typu po rozszerzeniu, jeÅ›li nie podano
if [[ -z "$TYPE" ]]; then
  case "${KS##*.}" in
    jks|JKS) TYPE="JKS" ;;
    p12|P12|pfx|PFX) TYPE="PKCS12" ;;
    *) TYPE="" ;; # keytool sprÃ³buje sam
  esac
fi

# HasÅ‚o â€“ poproÅ› jeÅ›li nie podane
if [[ -z "$PASS" ]]; then
  read -r -s -p "HasÅ‚o do keystore: " PASS; echo
fi

export LC_ALL=C

KT_ARGS=(-keystore "$KS" -storepass "$PASS")
[[ -n "$TYPE" ]] && KT_ARGS+=(-storetype "$TYPE")

# SprawdÅº dostÄ™p
if ! keytool -list "${KT_ARGS[@]}" >/dev/null 2>&1; then
  echo "BÅ‚Ä…d: nieprawidÅ‚owe hasÅ‚o/typ/plik (albo keystore uszkodzony)" >&2
  exit 1
fi

# Pobierz aliasy
mapfile -t ALIASES < <(keytool -list -v "${KT_ARGS[@]}" 2>/dev/null | awk -F': ' '/^Alias name:/{print $2}')
if [[ ${#ALIASES[@]} -eq 0 ]]; then
  echo "Brak aliasÃ³w w keystore lub brak uprawnieÅ„." >&2
  exit 0
fi

NOW_EPOCH=$(date +%s)

for alias in "${ALIASES[@]}"; do
  META=$(keytool -list -v -alias "$alias" "${KT_ARGS[@]}" 2>/dev/null || true)
  ENTRY_TYPE=$(awk -F': ' '/^Entry type:/{print $2}' <<<"$META")
  CHAIN_LEN=$(awk -F': ' '/^Certificate chain length:/{print $2}' <<<"$META")
  [[ -z "$CHAIN_LEN" ]] && CHAIN_LEN=1

  echo "----------------------------------------"
  echo "Alias:        $alias"
  echo "Typ wpisu:    ${ENTRY_TYPE:-nieznany}"
  echo "DÅ‚. Å‚aÅ„cucha: $CHAIN_LEN"

  if command -v openssl >/dev/null; then
    # wyeksportuj cert (leaf) i wypisz parametry
    if PEM=$(keytool -exportcert -alias "$alias" "${KT_ARGS[@]}" -rfc 2>/dev/null); then
      SUBJECT=$(openssl x509 -noout -subject    <<<"$PEM" | sed 's/^subject= //')
      ISSUER=$(openssl  x509 -noout -issuer     <<<"$PEM" | sed 's/^issuer= //')
      NB=$(openssl      x509 -noout -startdate  <<<"$PEM" | cut -d= -f2)
      NA=$(openssl      x509 -noout -enddate    <<<"$PEM" | cut -d= -f2)
      SERIAL=$(openssl  x509 -noout -serial     <<<"$PEM" | cut -d= -f2)
      FP=$(openssl      x509 -noout -fingerprint -sha256 <<<"$PEM" | cut -d= -f2)

      echo "Subject:      $SUBJECT"
      echo "Issuer:       $ISSUER"
      echo "Serial:       $SERIAL"
      echo "Not Before:   $NB"
      echo "Not After:    $NA"

      # policz dni do wygaÅ›niÄ™cia (GNU date)
      if END_EPOCH=$(date -d "$NA" +%s 2>/dev/null); then
        DAYS_LEFT=$(( (END_EPOCH - NOW_EPOCH) / 86400 ))
        echo "PozostaÅ‚o:    ${DAYS_LEFT} dni"
        if (( DAYS_LEFT <= WARN_DAYS )); then
          echo "UWAGA: certyfikat wygaÅ›nie w ${DAYS_LEFT} dni!"
        fi
      fi
      echo "SHA256 FP:    $FP"
    else
      echo "Nie udaÅ‚o siÄ™ wyeksportowaÄ‡ certyfikatu (alias: $alias)."
    fi
  else
    # Fallback bez openssl â€“ ograniczone info z keytool -list -v
    echo "$(sed -n -e 's/^Owner: \+//p' -e 's/^Subject: \+//p' -e 's/^Issuer: \+//p' -e 's/^Serial number: \+//p' -e 's/^Valid from: \+//p' <<<"$META")"
  fi
done
------------------
#!/bin/bash

VAULT_ADDR="http://vault.example.com:8200"
VAULT_USER="twoj_uzytkownik"
VAULT_PASS="twoje_haslo"
SECRET_PATH="secret/data/mysecret"  # zmieÅ„ jeÅ›li KV v1 na: secret/mysecret

# 1. Logowanie
VAULT_TOKEN=$(curl -s \
  --request POST \
  --data "{\"password\": \"${VAULT_PASS}\"}" \
  "${VAULT_ADDR}/v1/auth/userpass/login/${VAULT_USER}" \
  | jq -r '.auth.client_token')

if [ -z "$VAULT_TOKEN" ] || [ "$VAULT_TOKEN" == "null" ]; then
  echo "âŒ BÅ‚Ä…d: nie udaÅ‚o siÄ™ pobraÄ‡ tokena" >&2
  exit 1
fi

echo "âœ… Token pobrany: $VAULT_TOKEN"

# 2. Pobranie sekretu
RESPONSE=$(curl -s \
  -H "X-Vault-Token: ${VAULT_TOKEN}" \
  "${VAULT_ADDR}/v1/${SECRET_PATH}")

echo "ðŸ” PeÅ‚na odpowiedÅº z Vault:"
echo "$RESPONSE" | jq .

# 3. JeÅ›li KV v2 - same dane:
if [[ "$SECRET_PATH" == *"data/"* ]]; then
  echo "ðŸ“¦ Dane sekreta:"
  echo "$RESPONSE" | jq -r '.data.data'
fi


------
max(
  (
    (kafka_server_BrokerState{instance="broker1:7071"} >= 0)
    and on (instance) (rate(kafka_server_BrokerTopicMetrics_BytesInTotal{instance="broker1:7071"}[5m]) > 0)
    > bool 0
  )
  or on() (absent(kafka_server_BrokerState{instance="broker1:7071"}) * 0)
)

--

max(
  (
    (kafka_controller_ControllerStats_activeControllerCount{instance="controller1:7071"} >= 0)
    and on (instance) (rate(kafka_server_BrokerTopicMetrics_BytesInTotal{instance="controller1:7071"}[5m]) > 0)
    > bool 0
  )
  or on() (absent(kafka_controller_ControllerStats_activeControllerCount{instance="controller1:7071"}) * 0)
)

--------------------------------


(prometheus_build_info{job="prometheus"} == 1)
and (process_start_time_seconds{job="prometheus"} > 0)
and (increase(prometheus_tsdb_head_samples_appended_total{job="prometheus"}[5m]) > 0)
and (increase(prometheus_target_scrapes_total{job="prometheus"}[5m]) > 0)
--------------------
#!/bin/bash
# Skrypt: pokazuje szczegÃ³Å‚y wszystkich certyfikatÃ³w w pliku PEM
# UÅ¼ycie: ./show_certs.sh plik.pem

# Sprawdzenie argumentÃ³w
if [ $# -ne 1 ]; then
    echo "UÅ¼ycie: $0 plik_z_cert.pem"
    exit 1
fi

CERT_FILE="$1"

# Sprawdzenie czy plik istnieje
if [ ! -f "$CERT_FILE" ]; then
    echo "BÅ‚Ä…d: plik '$CERT_FILE' nie istnieje"
    exit 1
fi

# Przetwarzanie certyfikatÃ³w po kolei
csplit -f cert_part_ -b "%02d.pem" "$CERT_FILE" '/-----BEGIN CERTIFICATE-----/' '{*}' > /dev/null 2>&1

for cert in cert_part_*.pem; do
    if grep -q "BEGIN CERTIFICATE" "$cert"; then
        echo "========== Certyfikat: $cert =========="
        openssl x509 -noout -text -in "$cert"
        echo ""  # pusty wiersz miÄ™dzy certyfikatami
    fi
    rm -f "$cert"  # usuwanie pliku tymczasowego
done
-------------
#!/bin/bash

# Parametry (moÅ¼esz przekazaÄ‡ jako zmienne Å›rodowiskowe lub argumenty)
CERT="server.crt"
KEY="server.key"
CA="ca.crt"
P12="server.p12"
P12_ALIAS="myserver"
P12_PASS="p12haslo"
KEYSTORE="keystore.jks"
KEYSTORE_PASS="keystorehaslo"
TRUSTSTORE="truststore.jks"
TRUSTSTORE_PASS="truststorehaslo"
TRUSTSTORE_ALIAS="myca"

# 1. Tworzenie PKCS#12
openssl pkcs12 -export \
  -in "$CERT" \
  -inkey "$KEY" \
  -certfile "$CA" \
  -name "$P12_ALIAS" \
  -out "$P12" \
  -password pass:"$P12_PASS"

echo "PKCS#12 zapisany jako $P12"

# 2. Tworzenie keystore JKS z PKCS#12
keytool -importkeystore \
  -deststorepass "$KEYSTORE_PASS" \
  -destkeypass "$KEYSTORE_PASS" \
  -destkeystore "$KEYSTORE" \
  -srckeystore "$P12" \
  -srcstoretype PKCS12 \
  -srcstorepass "$P12_PASS" \
  -alias "$P12_ALIAS" \
  -noprompt

echo "Keystore JKS zapisany jako $KEYSTORE"

# 3. Tworzenie truststore JKS i import CA
keytool -importcert \
  -trustcacerts \
  -alias "$TRUSTSTORE_ALIAS" \
  -file "$CA" \
  -keystore "$TRUSTSTORE" \
  -storepass "$TRUSTSTORE_PASS" \
  -noprompt

echo "Truststore JKS zapisany jako $TRUSTSTORE"
