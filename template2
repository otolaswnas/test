#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import base64
import json
import re
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Optional, Tuple, Union

import requests
from requests.auth import HTTPBasicAuth
from requests.adapters import HTTPAdapter
from urllib.parse import quote
from urllib3.util.retry import Retry


# ----------------------------- Połączenie / Session -----------------------------

def create_es_session(
    base_url: str,
    basic_auth: Optional[Tuple[str, str]] = None,
    api_key: Optional[str] = None,   # "id:key" lub gotowy Base64
    verify: Union[bool, str] = True,
    default_headers: Optional[Dict[str, str]] = None,
    timeout: float = 30.0,
    retries: int = 3,
    backoff_factor: float = 0.5,
) -> requests.Session:
    """
    Tworzy sesję HTTP do Elasticsearch z nagłówkami i uwierzytelnieniem.
    - base_url: np. "https://localhost:9200"
    - basic_auth: ("user", "pass")
    - api_key: "id:key" (zostanie zbase64-owane) albo gotowy base64 (długa, bez dwukropka)
    - verify: True/False lub ścieżka do certyfikatu CA
    - timeout: domyślny timeout per-request (używany w helperze)
    - retries/backoff_factor: proste retry na 429/502/503/504
    """
    if api_key and basic_auth:
        raise ValueError("Podaj albo --api-key, albo --user/--password (nie oba).")

    s = requests.Session()
    s.verify = verify
    s.timeout = timeout  # używane przez es_request

    # Retry na typowych błędach i statusach
    retry = Retry(
        total=retries,
        connect=retries,
        read=retries,
        backoff_factor=backoff_factor,
        status_forcelist=(429, 502, 503, 504),
        allowed_methods=frozenset(["HEAD", "GET", "PUT", "POST", "DELETE", "OPTIONS"]),
        raise_on_status=False,
    )
    adapter = HTTPAdapter(max_retries=retry)
    s.mount("http://", adapter)
    s.mount("https://", adapter)

    headers = {"Accept": "application/json"}
    if default_headers:
        headers.update(default_headers)

    if api_key:
        if ":" in api_key:
            raw = api_key.encode("utf-8")
            encoded = base64.b64encode(raw).decode("ascii")
        else:
            encoded = api_key
        headers["Authorization"] = f"ApiKey {encoded}"

    if basic_auth:
        s.auth = HTTPBasicAuth(basic_auth[0], basic_auth[1])

    s.headers.update(headers)
    s.base_url = base_url.rstrip("/")  # własny atrybut pomocniczy
    return s


def es_request(
    session: requests.Session,
    method: str,
    path: str,
    params: Optional[Dict[str, Any]] = None,
    body: Optional[Any] = None,
    timeout: Optional[float] = None,
) -> Any:
    """
    Helper do wykonywania requestów na endpointy ES.
    Zwraca zdekodowane JSON (jeśli jest), albo tekst, albo None dla pustej odpowiedzi.
    Rzuca RuntimeError z czytelnym opisem przy błędzie HTTP/sieci.
    """
    url = f"{session.base_url}/{path.lstrip('/')}"
    try:
        resp = session.request(method, url, params=params, json=body, timeout=timeout or session.timeout)
    except requests.RequestException as e:
        raise RuntimeError(f"Request error {method} {url}: {e}") from e

    if not resp.ok:
        err_detail = ""
        try:
            payload = resp.json()
            if isinstance(payload, dict) and "error" in payload:
                err = payload["error"]
                if isinstance(err, dict):
                    reason = err.get("reason") or ""
                    etype = err.get("type") or ""
                    root = ""
                    if isinstance(err.get("root_cause"), list) and err["root_cause"]:
                        root = err["root_cause"][0].get("reason", "")
                    err_detail = " | ".join(x for x in [etype, reason, root] if x)
                else:
                    err_detail = str(err)
        except Exception:
            pass
        if not err_detail:
            err_detail = (resp.text or "").strip()
        raise RuntimeError(
            f"Elasticsearch API error {resp.status_code} {resp.reason} for {method} {url}: {err_detail}"
        )

    text = (resp.text or "").strip()
    if text:
        try:
            return resp.json()
        except json.JSONDecodeError:
            return text
    return None


# ----------------------------- Pobieranie templatek ----------------------------

def get_all_composable_templates(session: requests.Session) -> Dict[str, Dict[str, Any]]:
    """
    Zwraca dict: nazwa -> index_template body (gotowy do PUT /_index_template/{name})
    """
    data = es_request(session, "GET", "/_index_template")
    mapping: Dict[str, Dict[str, Any]] = {}
    for item in data.get("index_templates", []):
        name = item.get("name")
        body = item.get("index_template", {})
        if name:
            mapping[name] = body
    return mapping


def get_all_legacy_templates(session: requests.Session) -> Dict[str, Dict[str, Any]]:
    """
    Zwraca dict: nazwa -> legacy template body (gotowy do PUT /_template/{name})
    """
    data = es_request(session, "GET", "/_template")
    if isinstance(data, dict):
        return data
    return {}


def get_all_component_templates(session: requests.Session) -> Dict[str, Dict[str, Any]]:
    """
    Zwraca dict: nazwa -> component_template body (gotowy do PUT /_component_template/{name})
    """
    data = es_request(session, "GET", "/_component_template")
    mapping: Dict[str, Dict[str, Any]] = {}
    for item in data.get("component_templates", []):
        name = item.get("name")
        body = item.get("component_template", {})
        if name:
            mapping[name] = body
    return mapping


# ----------------------------- Backup do plików --------------------------------

def _sanitize_filename(name: str) -> str:
    # Bezpieczna nazwa pliku: litery, cyfry, -, _, .
    return re.sub(r"[^A-Za-z0-9._-]+", "_", name)


def backup_index_templates(
    session: requests.Session,
    out_dir: Optional[Path] = None,
    include_legacy: bool = True,
    include_components: bool = True,
) -> Path:
    """
    Tworzy folder z backupem wszystkich index/component templates.
    Struktura:
      backup_root/
        manifest.json
        component/<name>.json      (jeśli include_components=True)
        composable/<name>.json
        legacy/<name>.json         (jeśli include_legacy=True)
    Zwraca ścieżkę do katalogu backupu.
    """
    timestamp = datetime.utcnow().strftime("%Y%m%d-%H%M%S")
    root = Path(out_dir) if out_dir else Path(f"es_templates_backup-{timestamp}")
    (root / "composable").mkdir(parents=True, exist_ok=True)
    if include_legacy:
        (root / "legacy").mkdir(parents=True, exist_ok=True)
    if include_components:
        (root / "component").mkdir(parents=True, exist_ok=True)

    composable = get_all_composable_templates(session)
    legacy = get_all_legacy_templates(session) if include_legacy else {}
    component = get_all_component_templates(session) if include_components else {}

    entries = {"component": [], "composable": [], "legacy": []}

    # Zapis per-template + budowa manifestu (mapa plik -> oryginalna nazwa)
    for name, body in component.items():
        fn = _sanitize_filename(name) + ".json"
        rel = f"component/{fn}"
        with open(root / rel, "w", encoding="utf-8") as f:
            json.dump(body, f, indent=2, ensure_ascii=False)
        entries["component"].append({"name": name, "file": rel})

    for name, body in composable.items():
        fn = _sanitize_filename(name) + ".json"
        rel = f"composable/{fn}"
        with open(root / rel, "w", encoding="utf-8") as f:
            json.dump(body, f, indent=2, ensure_ascii=False)
        entries["composable"].append({"name": name, "file": rel})

    for name, body in legacy.items():
        fn = _sanitize_filename(name) + ".json"
        rel = f"legacy/{fn}"
        with open(root / rel, "w", encoding="utf-8") as f:
            json.dump(body, f, indent=2, ensure_ascii=False)
        entries["legacy"].append({"name": name, "file": rel})

    # Manifest
    manifest = {
        "created_at_utc": timestamp,
        "base_url": getattr(session, "base_url", ""),
        "counts": {
            "component": len(component),
            "composable": len(composable),
            "legacy": len(legacy),
        },
        "entries": entries,
        "note": "Pliki w podkatalogach są gotowe do PUT na odpowiednie endpointy. "
                "Nazwy oryginalne znajdują się w manifest.json (pliki mają nazwy zsanityzowane).",
    }
    with open(root / "manifest.json", "w", encoding="utf-8") as f:
        json.dump(manifest, f, indent=2, ensure_ascii=False)

    return root


# ----------------------------- Tworzenie / Nadpisywanie ------------------------

def _quote_name(name: str) -> str:
    return quote(name, safe="")


def put_index_template(
    session: requests.Session,
    name: str,
    body: Dict[str, Any],
    composable: bool = True,
    create: bool = False,
    cause: Optional[str] = None,
) -> Any:
    """
    Tworzy lub podmienia index template.
    - composable=True -> PUT /_index_template/{name}
    - composable=False (legacy) -> PUT /_template/{name}
    - create=True -> błąd jeśli istnieje
    - cause -> pojawi się w historii zmian (o ile obsługiwane)
    """
    params: Dict[str, Any] = {}
    if create:
        params["create"] = "true"
    if cause:
        params["cause"] = cause

    path = f"/_index_template/{_quote_name(name)}" if composable else f"/_template/{_quote_name(name)}"
    return es_request(session, "PUT", path, params=params, body=body)


def put_component_template(
    session: requests.Session,
    name: str,
    body: Dict[str, Any],
    create: bool = False,
    cause: Optional[str] = None,
) -> Any:
    """
    PUT component template: /_component_template/{name}
    """
    params: Dict[str, Any] = {}
    if create:
        params["create"] = "true"
    if cause:
        params["cause"] = cause

    path = f"/_component_template/{_quote_name(name)}"
    return es_request(session, "PUT", path, params=params, body=body)


def _load_manifest_map(source_dir: Path) -> Dict[str, str]:
    """
    Zwraca mapę 'relatywna_ścieżka_pliku' (POSIX) -> oryginalna nazwa z manifestu.
    Jeśli brak manifestu, zwraca pusty dict.
    """
    manifest_path = source_dir / "manifest.json"
    mapping: Dict[str, str] = {}
    if not manifest_path.exists():
        return mapping
    try:
        with open(manifest_path, "r", encoding="utf-8") as f:
            m = json.load(f)
        for bucket in ("component", "composable", "legacy"):
            for entry in m.get("entries", {}).get(bucket, []):
                file_rel = entry.get("file")
                name = entry.get("name")
                if file_rel and name:
                    mapping[file_rel] = name
    except Exception:
        # Nie psuj apply na uszkodzonym/nietypowym manifeście
        pass
    return mapping


def apply_templates_from_dir(
    session: requests.Session,
    source_dir: Path,
    only: str = "both",    # "both" | "composable" | "legacy" | "component" | "all"
    create: bool = False,
    verbose: bool = True,
) -> None:
    """
    Wczytuje pliki JSON z katalogu (strukturę jak z backupu) i robi PUT do ES.
    Domyślnie: komponenty (jeśli są) -> composable -> legacy.
    """
    source_dir = Path(source_dir)
    if not source_dir.exists():
        raise FileNotFoundError(f"Nie znaleziono katalogu: {source_dir}")

    manifest_map = _load_manifest_map(source_dir)

    def _get_original_name(path: Path, folder_name: str) -> str:
        rel = f"{folder_name}/{path.name}"
        return manifest_map.get(rel, path.stem)

    def apply_one_folder(folder: Path, kind: str):
        # kind: "component" | "composable" | "legacy"
        if not folder.exists():
            return 0, 0
        ok = 0
        fail = 0
        for path in sorted(folder.glob("*.json")):
            name = _get_original_name(path, folder.name)
            try:
                with open(path, "r", encoding="utf-8") as f:
                    body = json.load(f)
                if kind == "component":
                    put_component_template(session, name, body, create=create)
                elif kind == "composable":
                    put_index_template(session, name, body, composable=True, create=create)
                else:
                    put_index_template(session, name, body, composable=False, create=create)
                ok += 1
                if verbose:
                    print(f"[OK] {kind} -> {name}")
            except Exception as e:
                fail += 1
                print(f"[ERR] {kind} -> {name}: {e}")
        return ok, fail

    total_ok = total_fail = 0

    # Kolejność: component -> composable -> legacy
    if only in ("all", "both", "component"):
        ok, fail = apply_one_folder(source_dir / "component", kind="component")
        total_ok += ok
        total_fail += fail

    if only in ("all", "both", "composable"):
        ok, fail = apply_one_folder(source_dir / "composable", kind="composable")
        total_ok += ok
        total_fail += fail

    if only in ("all", "both", "legacy"):
        ok, fail = apply_one_folder(source_dir / "legacy", kind="legacy")
        total_ok += ok
        total_fail += fail

    print(f"Zakończono. Sukces: {total_ok}, błędy: {total_fail}")


def put_template_from_file(
    session: requests.Session,
    name: str,
    body_file: Path,
    composable: Optional[bool] = None,  # True/False dla index templates; None oznacza component
    create: bool = False,
    cause: Optional[str] = None,
) -> None:
    """
    PUT pojedynczego template z pliku JSON.
    - composable=True  -> PUT /_index_template/{name}
    - composable=False -> PUT /_template/{name} (legacy)
    - composable=None  -> PUT /_component_template/{name}
    """
    with open(body_file, "r", encoding="utf-8") as f:
        body = json.load(f)
    if composable is None:
        put_component_template(session, name, body, create=create, cause=cause)
    else:
        put_index_template(session, name, body, composable=composable, create=create, cause=cause)


# ----------------------------- CLI ---------------------------------------------

def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Backup i odtwarzanie index/component templates (REST API, bez biblioteki elasticsearch)")

    # Wspólne połączenie
    p.add_argument("--base-url", required=True, help="URL klastra ES, np. https://localhost:9200")
    p.add_argument("--user", help="Użytkownik (Basic Auth)")
    p.add_argument("--password", help="Hasło (Basic Auth)")
    p.add_argument("--api-key", help='ApiKey w formacie "id:key" lub już zbase64-owane')
    p.add_argument("--insecure", action="store_true", help="Nie weryfikuj certyfikatu TLS (verify=False)")
    p.add_argument("--ca-cert", help="Ścieżka do certyfikatu CA (verify=<path>)")
    p.add_argument("--timeout", type=float, default=30.0, help="Timeout w sekundach (domyślnie 30)")

    sub = p.add_subparsers(dest="cmd", required=True)

    # backup
    p_backup = sub.add_parser("backup", help="Zrób backup index i component templates do katalogu")
    p_backup.add_argument("--out-dir", help="Katalog docelowy (domyślnie es_templates_backup-<TS>)")
    p_backup.add_argument("--no-legacy", action="store_true", help="Pomiń legacy templates")
    p_backup.add_argument("--no-components", action="store_true", help="Pomiń component templates")

    # apply
    p_apply = sub.add_parser("apply", help="Wgraj (PUT) templates z katalogu backupu")
    p_apply.add_argument("--src-dir", required=True, help="Katalog z backupem")
    p_apply.add_argument("--only", choices=["both", "composable", "legacy", "component", "all"], default="both", help="Zakres wgrywania (component -> composable -> legacy)")
    p_apply.add_argument("--create", action="store_true", help="Użyj ?create=true (zawiedzie, jeśli istnieje)")

    # put-one
    p_put = sub.add_parser("put-one", help="PUT pojedynczego template z pliku JSON")
    p_put.add_argument("--name", required=True, help="Nazwa template")
    kind = p_put.add_mutually_exclusive_group(required=True)
    kind.add_argument("--composable", action="store_true", help="Composable index template")
    kind.add_argument("--legacy", action="store_true", help="Legacy index template")
    kind.add_argument("--component", action="store_true", help="Component template")
    p_put.add_argument("--file", required=True, help="Plik JSON z ciałem template")
    p_put.add_argument("--create", action="store_true", help="Użyj ?create=true")
    p_put.add_argument("--cause", help="Opis zmiany (cause)")

    return p.parse_args()


def main():
    args = parse_args()

    # Walidacja auth: nie pozwól na mieszanie Basic i ApiKey
    if args.api_key and (args.user or args.password):
        raise SystemExit("Błąd: podaj albo --api-key, albo --user razem z --password (nie oba naraz).")
    if (args.user and not args.password) or (args.password and not args.user):
        raise SystemExit("Błąd: do Basic Auth podaj jednocześnie --user i --password.")

    verify: Union[bool, str] = True
    if args.insecure:
        verify = False
    elif args.ca_cert:
        verify = args.ca_cert

    basic_auth = (args.user, args.password) if args.user and args.password else None

    session = create_es_session(
        base_url=args.base_url,
        basic_auth=basic_auth,
        api_key=args.api_key,
        verify=verify,
        timeout=args.timeout,
        retries=3,
        backoff_factor=0.5,
    )

    if args.cmd == "backup":
        include_legacy = not args.no_legacy
        include_components = not args.no_components
        out_dir = Path(args.out_dir) if args.out_dir else None
        target = backup_index_templates(
            session,
            out_dir=out_dir,
            include_legacy=include_legacy,
            include_components=include_components,
        )
        print(f"Backup zapisany w: {target.resolve()}")

    elif args.cmd == "apply":
        apply_templates_from_dir(
            session,
            source_dir=Path(args.src_dir),
            only=args.only,
            create=args.create,
            verbose=True,
        )

    elif args.cmd == "put-one":
        if args.component:
            composable_flag = None  # component
        elif args.composable:
            composable_flag = True
            # composable index template
        else:
            composable_flag = False  # legacy

        put_template_from_file(
            session,
            name=args.name,
            body_file=Path(args.file),
            composable=composable_flag,
            create=args.create,
            cause=args.cause,
        )
        kind = "component" if args.component else ("composable" if args.composable else "legacy")
        print(f"PUT {kind} template '{args.name}' wykonany.")

    else:
        raise SystemExit("Nieznane polecenie")


if __name__ == "__main__":
    main()
